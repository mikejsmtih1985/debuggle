<!--
🎨 DEBUGGLE WEB DASHBOARD - The Digital Control Center (2,700+ Lines!)
========================================================================

This HTML file creates the beautiful, interactive web interface for Debuggle's
error analysis system. Think of it as designing a modern, user-friendly 
control panel for a high-tech spacecraft or research facility.

🏆 HIGH SCHOOL EXPLANATION:
Imagine you're building a professional website that looks like something from
a sci-fi movie - clean, modern, and powerful. This massive file contains three main parts:

1. 📋 HTML STRUCTURE (Lines 1-1200) - Like the blueprint of a building, defining what goes where
2. 🎨 CSS STYLING (Lines 100-1100) - Like interior decorating, making everything look beautiful
3. ⚡ JAVASCRIPT CODE (Lines 1200-2700) - Like the electrical system, making everything interactive

🌟 KEY FEATURES IMPLEMENTED:
✅ Drag & Drop File Upload - Intuitive file selection with visual feedback
✅ Real-Time Progress Tracking - Live updates during file processing
✅ WebSocket Communication - Instant error notifications without page refresh
✅ Interactive Dashboard Elements - Buttons, toggles, and dynamic content
✅ Responsive Design - Works perfectly on desktop, tablet, and mobile
✅ Professional Styling - Modern gradients, shadows, and animations
✅ Error Handling - Graceful recovery from problems and clear user feedback

🎯 MAJOR COMPONENTS EXPLAINED:
• File Upload Zone - Drag & drop interface with hover effects and processing states
• Progress Indicators - Visual feedback during file analysis operations  
• Results Display - Formatted output with syntax highlighting and interactive tags
• Real-Time Monitoring - WebSocket connection for live error notifications
• Control Panels - User preferences and analysis options
• Responsive Layout - Automatic adjustment for different screen sizes

EDUCATIONAL METAPHORS USED IN THIS FILE:
🏗️ Architecture & Construction - HTML structure like building blueprints
🎨 Interior Design - CSS styling like decorating and furniture arrangement  
⚡ Electrical Systems - JavaScript like wiring that makes everything work
🎭 Theater Production - Event handling like stage cues and lighting
🚀 Spacecraft Controls - Dashboard elements like mission control panels
📡 Communication Systems - WebSocket connections like radio/satellite links
🏭 Factory Automation - File processing workflows like assembly lines

The goal is to make complex error analysis feel approachable and intuitive,
like using a well-designed mobile app instead of scary command-line tools.
-->

<!DOCTYPE html>
<!--
📋 DOCUMENT BLUEPRINT - Telling the browser what kind of web page this is

The DOCTYPE declaration is like putting a label on a blueprint that says
"This is a modern web page design using HTML5 standards." It ensures the
browser interprets our code correctly, like making sure an architect and
contractor are using the same measurement system.
-->

<html lang="en">
<!--
🌍 LANGUAGE SETTINGS - Setting up international compatibility

The 'lang="en"' attribute tells browsers, screen readers, and search engines
that this page is written in English. It's like putting a language label
on a document so translation services know how to handle it properly.
-->

<head>
    <!--
    🧠 PAGE BRAIN - The control center that browsers read first
    
    The <head> section is like the control room of our web page. Users don't
    see this directly, but it contains all the important instructions that
    tell the browser how to display and behave. Think of it like the backstage
    area of a theater production - essential for the show, but hidden from the audience.
    -->
    
    <!-- 🔤 CHARACTER ENCODING - Making sure all text displays correctly -->
    <meta charset="UTF-8">
    <!--
    This tells the browser how to interpret text characters, including emojis,
    special symbols, and international characters. UTF-8 is like a universal
    translator that can handle almost any language or symbol.
    -->
    
    <!-- 📱 MOBILE OPTIMIZATION - Making sure the page looks good on phones and tablets -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
    This magic line ensures our dashboard looks great on everything from
    giant desktop monitors to tiny phone screens. It's like having a responsive
    design that automatically adjusts, similar to how a good website should
    look perfect whether you're on a laptop or smartphone.
    -->
    
    <!-- 🏷️ PAGE TITLE - What appears in the browser tab -->
    <title>🐞 Debuggle - Error Analysis Tool</title>
    <!--
    This is what users see in their browser tab and bookmarks. The bug emoji
    makes it instantly recognizable among dozens of open tabs, like having
    a distinctive logo on a storefront.
    -->
    
    <!--
    🎨 STYLESHEET SECTION - The Interior Design Department
    ========================================================
    
    Everything between <style> tags is CSS (Cascading Style Sheets), which is
    like having a team of interior designers who decide how everything looks:
    colors, fonts, layouts, animations, and visual effects.
    
    🏆 HIGH SCHOOL EXPLANATION:
    Think of CSS like decorating a house:
    - HTML is the house structure (walls, rooms, doors)
    - CSS is the decoration (paint colors, furniture, lighting)
    - JavaScript is the utilities (plumbing, electrical, smart home features)
    
    We'll use metaphors like interior design, architecture, and visual arts
    to explain how CSS creates beautiful, professional interfaces.
    -->
    <style>
        /*
        🧹 UNIVERSAL RESET - Starting with a clean slate
        ================================================
        
        This CSS rule applies to every single element on the page (that's what * means).
        It's like having a cleaning crew come through and remove all the default
        spacing and formatting that browsers add automatically.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Imagine you're redecorating a room. Before you can arrange your furniture
        exactly how you want it, you need to:
        1. Remove all existing furniture (margin: 0, padding: 0)
        2. Measure everything consistently (box-sizing: border-box)
        
        Without this reset, different browsers would display our page slightly
        differently, like having different sized rooms in different buildings.
        */
        * {
            margin: 0;          /* 📏 Remove all outer spacing around elements */
            padding: 0;         /* 📦 Remove all inner spacing inside elements */
            box-sizing: border-box;  /* 📐 Make size calculations predictable and consistent */
        }

        /*
        🏠 MAIN CANVAS - Setting up our page background and foundation
        =============================================================
        
        The body element is like the main canvas or stage where our entire
        interface will be painted. This is where we set the overall mood,
        color scheme, and basic layout foundation.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like setting up a photography studio:
        1. Choose the backdrop color/pattern (background gradient)
        2. Set up proper lighting (font choices for readability)  
        3. Arrange the space (padding, height settings)
        4. Make sure everything fits in the frame (min-height: 100vh)
        */
        body {
            /* 🖋️ TYPOGRAPHY SETUP - Choosing the best fonts for readability */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /*
            This font stack is like having backup singers ready. The browser tries:
            1. Apple's system font (on Mac/iOS) - looks native and familiar
            2. Microsoft's Segoe UI (on Windows) - clean and professional  
            3. Roboto (on Android) - modern and readable
            4. Generic sans-serif as final backup - always works
            */
            
            /* 🌈 BACKGROUND MAGIC - Creating a beautiful color gradient */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            /*
            This creates a diagonal color fade from blue to purple, like a sunset
            or professional presentation background. The degrees (135deg) control
            the angle, and percentages (0%, 100%) control where colors transition.
            */
            
            /* 📐 LAYOUT FOUNDATION - Setting up the basic page structure */
            min-height: 100vh;  /* 📏 Ensure page fills the full viewport height (100vh = 100% of visible height) */
            padding: 20px;      /* 🎯 Add breathing room around the edges */
        }

        /*
        🏢 MAIN DASHBOARD CONTAINER - The control center housing
        =======================================================
        
        This creates the main "building" that houses our entire dashboard.
        Think of it like designing a modern office building or spacecraft
        control center that sits beautifully in the landscape.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Imagine you're an architect designing a high-tech control center:
        1. Size limits (max-width) - don't make it too wide for readability
        2. Centering (margin: 0 auto) - place it perfectly in the middle
        3. Clean background (white) - professional, neutral workspace
        4. Rounded corners (border-radius) - modern, friendly appearance
        5. Floating effect (box-shadow) - makes it appear to hover above background
        */
        .container {
            max-width: 1200px;                              /* 📏 Maximum width prevents reading difficulty on huge screens */
            margin: 0 auto;                                 /* 🎯 Center the container horizontally on the page */
            background: white;                              /* 🤍 Clean, professional workspace background */
            border-radius: 20px;                           /* 🔘 Smooth, modern rounded corners */
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);      /* ✨ Subtle shadow creates floating effect */
            overflow: hidden;                              /* 📦 Ensure child elements stay within rounded corners */
        }

        /*
        🎪 DASHBOARD HEADER - The welcoming entrance and title area
        ==========================================================
        
        The header is like the impressive entrance lobby of our control center.
        It needs to make a great first impression and clearly communicate what
        this system does, like the marquee sign outside a theater.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like designing the entrance to a theme park or museum:
        1. Eye-catching colors (gradient background) - draws attention
        2. Clear branding (centered text) - tells people where they are  
        3. Professional spacing (padding) - gives content room to breathe
        4. Consistent color scheme - matches the overall design theme
        */
        .header {
            /* 🌊 HEADER BACKGROUND - Creating visual impact with color flow */
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            /*
            A darker blue gradient that complements our page background,
            like having coordinated colors in interior design. Creates
            a professional, trustworthy feeling like bank or tech company branding.
            */
            
            color: white;           /* 🤍 White text for maximum contrast and readability */
            padding: 30px;          /* 🎭 Generous spacing for an impressive, uncluttered look */
            text-align: center;     /* 🎯 Center-align all header content for balance */
        }

        /*
        📢 MAIN TITLE STYLING - Making the page title stand out
        =======================================================
        
        The h1 (heading 1) is like the main sign or logo - it needs to be
        immediately visible and communicate the purpose of our tool.
        */
        .header h1 {
            font-size: 2.5em;      /* 📏 Large, attention-grabbing size (2.5 times normal text) */
            margin-bottom: 10px;    /* 📐 Small gap before the subtitle */
        }

        /*
        💬 SUBTITLE STYLING - Supporting information that explains our purpose
        ====================================================================
        
        The paragraph text provides context and description, like the tagline
        under a company logo or the subtitle on a movie poster.
        */
        .header p {
            font-size: 1.2em;      /* 📏 Slightly larger than normal text for emphasis */
            opacity: 0.9;          /* 🌫️ Slightly transparent for subtle, elegant effect */
        }

        /*
        🏢 MAIN WORKSPACE - The primary working area of our dashboard
        ============================================================
        
        This is like the main floor of our control center where all the
        important work happens. It needs generous spacing so content
        doesn't feel cramped, like having a spacious office layout.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like the main area of a well-designed store or restaurant:
        - Plenty of space to move around comfortably (padding: 40px)
        - Clean, uncluttered feeling that focuses attention on important content
        - Professional spacing that makes everything feel organized and premium
        */
        .main-content {
            padding: 40px;      /* 🎭 Generous spacing creates a premium, comfortable feeling */
        }

        /*
        📁 FILE UPLOAD ZONE - The primary interaction area for users
        ===========================================================
        
        This section is like the reception desk or main service counter
        where users first interact with our system. It needs to be
        prominent and inviting, like the entrance to a helpful service.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like the main counter at a phone repair shop or
        copy center - it's where customers bring their "problems" (log files)
        to get help. The spacing ensures it stands out as the primary action area.
        */
        .upload-section {
            margin-bottom: 40px;    /* 📐 Space separation from other sections below */
        }

        /*
        🎯 DRAG & DROP INTERFACE - The interactive file upload area
        ==========================================================
        
        This creates the main "drop zone" where users can drag files from
        their computer, like having a designated landing pad for incoming
        spacecraft or a collection box for important documents.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like designing a dropbox or collection bin that:
        1. Looks clearly different from regular content (dashed border)
        2. Feels interactive and clickable (rounded corners, hover effects)
        3. Gives visual feedback when users interact with it (color changes)
        4. Has plenty of space so it's easy to "hit the target"
        */
        .drag-drop-area {
            border: 3px dashed #ddd;        /* 📦 Dashed border shows this is a "drop zone" */
            border-radius: 15px;            /* 🔘 Rounded corners feel modern and friendly */
            padding: 60px 20px;             /* 🎭 Generous padding makes target easy to hit */
            text-align: center;             /* 🎯 Center all content for balanced appearance */
            transition: all 0.3s ease;      /* ✨ Smooth animation for all property changes */
            cursor: pointer;                /* 👆 Show hand cursor to indicate clickability */
            background: #f8f9fa;            /* 🌫️ Light gray background, subtle and clean */
        }

        /*
        🎨 INTERACTIVE FEEDBACK - Visual responses to user actions
        =========================================================
        
        These rules create different visual states that give users immediate
        feedback about what's happening, like traffic lights or status indicators.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like a smart doorbell or gaming controller that lights up:
        1. Hover state - changes color when you move mouse over it
        2. Drag-over state - special color when dragging a file over it  
        3. Processing state - different color when actively working
        
        This makes the interface feel alive and responsive, like a good video game.
        */
        .drag-drop-area:hover,              /* 👆 When user hovers mouse over the area */
        .drag-drop-area.drag-over {         /* 📁 When user is dragging a file over it */
            border-color: #2a5298;          /* 🔵 Change to blue border - "ready to receive" */
            background: #e3f2fd;            /* 💙 Light blue background - "active and ready" */
        }

        .drag-drop-area.processing {        /* ⚙️ When the system is actively processing files */
            border-color: #ff9800;          /* 🟠 Orange border - "working on it" */
            background: #fff3e0;            /* 🧡 Light orange background - "please wait" */
        }

        /*
        📁 UPLOAD ICON - The visual symbol that communicates purpose
        ===========================================================
        
        The folder emoji serves as an international symbol that immediately
        tells users "this is where files go," like having clear signage
        in an airport or universal symbols on appliances.
        */
        .upload-icon {
            font-size: 4em;                 /* 📏 Large size makes it impossible to miss */
            margin-bottom: 20px;            /* 📐 Space between icon and text */
            color: #666;                    /* 🌫️ Neutral gray color, professional but friendly */
        }

        /*
        💬 PRIMARY INSTRUCTION TEXT - Clear, action-oriented guidance
        ============================================================
        
        This text tells users exactly what they can do, like having clear
        instructions on a vending machine or self-checkout kiosk.
        */
        .upload-text {
            font-size: 1.3em;              /* 📏 Slightly larger for emphasis and readability */
            color: #666;                    /* 🌫️ Consistent color scheme with icon */
            margin-bottom: 10px;            /* 📐 Small gap before secondary instructions */
        }

        .upload-subtext {
            color: #999;
            margin-bottom: 30px;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(42, 82, 152, 0.3);
        }

        .options-section {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .option-group label {
            font-weight: 600;
            color: #333;
        }

        .option-group select,
        .option-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
        }

        .toggle-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .toggle-button {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #6c757d;
            border: 2px solid #dee2e6;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .toggle-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .toggle-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            border-color: #adb5bd;
        }

        .toggle-button:hover::before {
            left: 100%;
        }

        .toggle-button.active {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border-color: #2a5298;
            box-shadow: 0 6px 20px rgba(42, 82, 152, 0.3);
        }

        .toggle-button.active:hover {
            box-shadow: 0 8px 25px rgba(42, 82, 152, 0.4);
            transform: translateY(-3px);
        }

        .toggle-button.active::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
        }

        .toggle-button.processing {
            animation: pulseProcess 1s ease-in-out infinite;
        }

        @keyframes pulseProcess {
            0% { box-shadow: 0 6px 20px rgba(42, 82, 152, 0.3); }
            50% { box-shadow: 0 6px 25px rgba(255, 107, 53, 0.4); }
            100% { box-shadow: 0 6px 20px rgba(42, 82, 152, 0.3); }
        }

        /* Multi-file tab system */
        .file-tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            overflow-x: auto;
            border-bottom: 2px solid #dee2e6;
            margin-top: 20px;
        }

        .file-tab {
            padding: 12px 20px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            color: #6c757d;
            border-radius: 8px 8px 0 0;
            margin-right: 2px;
        }

        .file-tab:hover {
            background: #dee2e6;
            color: #495057;
        }

        .file-tab.active {
            background: #2a5298;
            color: white;
            box-shadow: 0 2px 8px rgba(42, 82, 152, 0.3);
        }

        .file-tab.processing {
            background: #ff9800;
            color: white;
            animation: pulseTab 1s ease-in-out infinite;
        }

        @keyframes pulseTab {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .tab-content {
            display: none;
            background: white;
            border-radius: 0 0 10px 10px;
            border: 2px solid #dee2e6;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        .file-queue {
            display: none;
            margin: 20px 0;
        }

        .file-queue.show {
            display: block;
        }

        .file-item {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .file-item.processed {
            border-color: #28a745;
            background: #d4edda;
        }

        .file-item.processing {
            border-color: #ff9800;
            background: #fff3e0;
        }

        .file-item.error {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .file-info-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-icon-large {
            font-size: 2em;
        }

        .file-details-multi {
            flex-grow: 1;
        }

        .file-details-multi h4 {
            margin: 0 0 5px 0;
            color: #333;
        }

        .file-details-multi p {
            margin: 0;
            color: #666;
            font-size: 0.9em;
        }

        .file-actions-multi {
            display: flex;
            gap: 10px;
        }

        .process-all-section {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .hidden-checkbox {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2a5298, #667eea);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-section {
            margin-top: 40px;
            display: none;
        }

        .results-header {
            background: #e8f5e8;
            padding: 20px;
            border-radius: 10px 10px 0 0;
            border-left: 4px solid #4caf50;
        }

        .results-content {
            background: #f8f9fa;
            color: #333;
            padding: 20px;
            border-radius: 0 0 10px 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 15px;
            line-height: 1.8;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .results-content.plain-mode {
            background: #ffffff;
            border: 1px solid #dee2e6;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            padding: 15px;
        }

        .timestamp {
            background: #e3f2fd;
            color: #1565c0;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 13px;
        }

        .log-error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #c62828;
        }

        .log-security {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #f57c00;
        }

        .log-warning {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #f9a825;
        }

        .log-success {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #2e7d32;
        }

        .log-info {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #7b1fa2;
        }

        .log-repeated {
            background: #fce4ec;
            border-left: 4px solid #e91e63;
            padding: 8px 16px;
            margin: 4px 0;
            border-radius: 6px;
            color: #c2185b;
            font-weight: 600;
        }

        .log-normal {
            padding: 8px 16px;
            margin: 4px 0;
            color: #666;
        }

        .log-plain {
            padding: 4px 8px;
            margin: 2px 0;
            color: #333;
            background: white;
            border: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .log-plain.highlighted {
            background: #fff3cd !important;
            border-left: 3px solid #ffc107 !important;
            padding-left: 12px !important;
        }

        .summary-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .summary-header {
            font-weight: 600;
            color: #856404;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tags-section {
            margin: 20px 0;
        }

        .tag {
            display: inline-block;
            background: #2a5298;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            margin: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tag:hover {
            background: #1e3c72;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(42, 82, 152, 0.3);
        }

        .tag.active {
            background: #ff6b35;
            box-shadow: 0 0 0 2px #ff6b35, 0 0 10px rgba(255, 107, 53, 0.3);
        }

        .log-entry.highlighted {
            animation: highlightPulse 0.6s ease-in-out;
            box-shadow: 0 0 0 3px #ff6b35, 0 4px 12px rgba(255, 107, 53, 0.2);
            transform: scale(1.02);
        }

        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 0 #ff6b35; }
            50% { box-shadow: 0 0 0 6px rgba(255, 107, 53, 0.4); }
            100% { box-shadow: 0 0 0 3px #ff6b35; }
        }

        .metadata-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .metadata-item {
            text-align: center;
        }

        .metadata-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #2a5298;
        }

        .metadata-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #dc3545;
        }

        .file-preview {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        .file-preview.show {
            display: block;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-icon {
            font-size: 3em;
            color: #4caf50;
        }

        .file-details h3 {
            margin: 0 0 5px 0;
            color: #2e7d32;
            font-size: 1.2em;
        }

        .file-details p {
            margin: 0;
            color: #666;
            font-size: 0.9em;
        }

        .file-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn-small {
            background: #2a5298;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            background: #1e3c72;
            transform: translateY(-1px);
        }

        .btn-remove {
            background: #dc3545;
        }

        .btn-remove:hover {
            background: #c82333;
        }

        .upload-success {
            color: #4caf50;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drag-drop-area.file-selected {
            border-color: #4caf50;
            background: #f1f8e9;
            padding: 30px 20px;
        }

        .drag-drop-area.file-selected .upload-icon {
            color: #4caf50;
        }

        .drag-drop-area.file-selected .upload-text {
            color: #2e7d32;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Real-time notification animations */
        @keyframes slideInRight {
            from {
                transform: translateX(300px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(300px);
                opacity: 0;
            }
        }

        /* Self-monitoring panel styles */
        .self-monitoring-section {
            margin-top: 40px;
            background: linear-gradient(135deg, #fff3e0 0%, #fce4ec 100%);
            border-radius: 15px;
            border: 2px solid #ff6b35;
            overflow: hidden;
        }

        .self-monitoring-section .section-header {
            background: linear-gradient(135deg, #ff6b35 0%, #c44569 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .self-monitoring-section h3 {
            margin: 0;
            font-size: 1.4em;
        }

        .self-monitoring-section .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .self-monitoring-status {
            padding: 20px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .self-monitoring-status p {
            margin: 0;
            font-weight: 600;
        }

        .self-monitoring-status span {
            color: #c44569;
            font-weight: 700;
        }

        .self-monitoring-errors {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .self-error-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #ff6b35;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.1);
        }

        .self-error-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .self-error-type {
            font-weight: 700;
            color: #c44569;
        }

        .self-error-time {
            font-size: 0.9em;
            color: #666;
        }

        .self-error-message {
            margin-bottom: 8px;
            color: #333;
        }

        .self-error-context {
            font-size: 0.9em;
            color: #666;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .options-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🐞 Debuggle</h1>
            <p>Transform chaotic logs into clear, understandable insights</p>
            <div style="margin-top: 15px;">
                <button class="btn-secondary" onclick="toggleSelfMonitoringPanel()" id="showSelfMonitoring">
                    🔧 Developer Tools
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <div class="drag-drop-area" id="dragDropArea">
                    <div class="upload-icon">📁</div>
                    <div class="upload-text">Drag & drop your log file(s) here</div>
                    <div class="upload-subtext">Single files auto-analyze • Multiple files need manual analysis</div>
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                    <input type="file" id="fileInput" class="file-input" accept=".log,.txt,.out,.err,.json" multiple>
                </div>

                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div class="file-preview" id="filePreview">
                    <div class="file-info">
                        <div class="file-icon">📄</div>
                        <div class="file-details">
                            <h3 id="fileName">filename.log</h3>
                            <p id="fileSize">File size • Ready to analyze</p>
                        </div>
                    </div>
                    <div class="file-actions">
                        <div class="upload-success" id="uploadSuccess" style="display: none;">
                            ✅ File uploaded successfully!
                        </div>
                        <button class="btn-small" onclick="processFile()" id="processBtn">
                            Process File
                        </button>
                        <button class="btn-small btn-remove" onclick="removeFile()" id="removeBtn">
                            Remove
                        </button>
                    </div>
                </div>
            </div>

            <div class="options-section">
                <div class="toggle-group">
                    <input type="checkbox" id="summarize" class="hidden-checkbox" checked>
                    <div class="toggle-button active" onclick="toggleOption('summarize', this)">
                        🧠 Generate Smart Analysis
                    </div>
                </div>

                <div class="toggle-group">
                    <input type="checkbox" id="tags" class="hidden-checkbox" checked>
                    <div class="toggle-button active" onclick="toggleOption('tags', this)">
                        🏷️ Show Interactive Tags
                    </div>
                </div>

                <div class="toggle-group">
                    <input type="checkbox" id="highlight" class="hidden-checkbox" checked>
                    <div class="toggle-button active" onclick="toggleOption('highlight', this)">
                        ✨ Enhanced Formatting
                    </div>
                </div>
            </div>

            <div class="results-section" id="resultsSection">
                <div id="summarySection" class="summary-section" style="display: none;">
                    <div class="summary-header">
                        🧠 Smart Analysis
                    </div>
                    <div id="summaryContent"></div>
                </div>

                <div id="tagsSection" class="tags-section" style="display: none;">
                    <strong>Tags:</strong>
                    <div id="tagsContent"></div>
                </div>

                <div class="results-header">
                    <strong>🔍 Analyzed Log Output</strong>
                </div>
                <div class="results-content" id="resultsContent"></div>

                <div class="metadata-section" id="metadataSection">
                    <!-- Metadata will be populated here -->
                </div>
            </div>

            <!-- Self-monitoring panel -->
            <div class="self-monitoring-section" id="selfMonitoringSection" style="display: none;">
                <div class="section-header">
                    <h3>🐞 Debuggle Self-Monitoring</h3>
                    <div class="controls">
                        <button class="btn-secondary" onclick="toggleSelfMonitoring()" id="selfMonitoringToggle">
                            Enable Monitoring
                        </button>
                        <button class="btn-secondary" onclick="clearSelfMonitoringErrors()">
                            Clear Errors
                        </button>
                        <button class="btn-secondary" onclick="testSelfMonitoring()">
                            Test Error
                        </button>
                        <button class="btn-secondary" onclick="toggleSelfMonitoringPanel()">
                            Hide Panel
                        </button>
                    </div>
                </div>
                <div class="self-monitoring-status" id="selfMonitoringStatus">
                    <p>Status: <span id="monitoringStatusText">Checking...</span></p>
                    <p>Internal Errors: <span id="errorCountText">0</span></p>
                </div>
                <div class="self-monitoring-errors" id="selfMonitoringErrors">
                    <!-- Recent errors will appear here -->
                </div>
            </div>

            <div id="errorMessage" class="error-message" style="display: none;"></div>
        </div>
    </div>

    <!--
    ⚡ JAVASCRIPT CONTROL SYSTEM - The Brain and Nervous System of Our Dashboard
    ===========================================================================
    
    Everything between <script> tags is JavaScript code - the "electrical system"
    that makes our beautiful dashboard actually work and respond to user actions.
    
    🏆 HIGH SCHOOL EXPLANATION:
    Think of our web page like a sophisticated smart home or gaming setup:
    
    1. 📋 HTML = The house structure (rooms, walls, doors, windows)
    2. 🎨 CSS = The decoration and design (paint, furniture, lighting)  
    3. ⚡ JAVASCRIPT = The electrical and smart systems (lights, security, automation)
    
    JavaScript is what turns our static, pretty webpage into an interactive,
    intelligent system that can:
    - Respond to mouse clicks and keyboard input
    - Communicate with servers over the internet
    - Update content in real-time without page refreshes
    - Process files and display results dynamically
    
    We'll use metaphors like electrical systems, control panels, automation,
    and smart home technology to explain how JavaScript creates interactivity.
    -->
    <script>
        /*
        🎛️ CONTROL PANEL CONNECTIONS - Linking JavaScript to HTML elements
        ==================================================================
        
        These variables are like connecting wires that link our JavaScript "brain"
        to specific parts of our HTML interface. Each getElementById() call is
        like plugging a wire into a specific component on our control panel.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like setting up a home theater system where you need to
        connect the remote control to each device:
        - dragDropArea = connect to the file drop zone
        - progressBar = connect to the loading indicator  
        - resultsSection = connect to the output display
        
        Once connected, our JavaScript can control these elements, change their
        content, hide/show them, or respond when users interact with them.
        */
        
        // 📱 USER INTERFACE CONTROLS - connecting to interactive elements
        const dragDropArea = document.getElementById('dragDropArea');      // 🎯 File drop zone
        const fileInput = document.getElementById('fileInput');            // 📁 Hidden file picker
        const progressBar = document.getElementById('progressBar');        // 📊 Loading indicator container
        const progressFill = document.getElementById('progressFill');      // 📈 Actual progress bar fill
        
        // 📺 DISPLAY SCREENS - connecting to content display areas
        const resultsSection = document.getElementById('resultsSection');    // 📋 Main results container
        const resultsContent = document.getElementById('resultsContent');    // 📄 Processed log content
        const summarySection = document.getElementById('summarySection');    // 🧠 AI analysis summary
        const summaryContent = document.getElementById('summaryContent');    // 💭 Summary text content
        const tagsSection = document.getElementById('tagsSection');          // 🏷️ Interactive tags area
        const tagsContent = document.getElementById('tagsContent');          // 🎯 Tag buttons container
        
        // 📋 STATUS AND FEEDBACK DISPLAYS - connecting to user feedback elements
        const metadataSection = document.getElementById('metadataSection');  // 📊 File information display
        const errorMessage = document.getElementById('errorMessage');        // ⚠️ Error notification area
        const filePreview = document.getElementById('filePreview');          // 👁️ File preview container
        const fileName = document.getElementById('fileName');                // 📄 Display selected filename
        const fileSize = document.getElementById('fileSize');                // 📏 Display file size info
        const uploadSuccess = document.getElementById('uploadSuccess');      // ✅ Success notification
        
        // 🎮 ACTION BUTTONS - connecting to user controls
        const processBtn = document.getElementById('processBtn');            // ⚡ Process/analyze button
        const removeBtn = document.getElementById('removeBtn');              // 🗑️ Remove file button
        
        /*
        📡 REAL-TIME COMMUNICATION SYSTEM - Live connection to server
        ============================================================
        
        These variables set up our "radio communication" system that lets our
        dashboard talk to the server in real-time, like having a live video call
        or chat connection that stays open for instant updates.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like having a walkie-talkie or Discord voice chat that
        stays connected while you're playing online games:
        - websocket = the open communication channel
        - realtimeErrors = a list of all messages received
        - connectionStatus = whether we're currently "online" or "offline"
        */
        let websocket = null;                    // 📻 Real-time communication channel
        let realtimeErrors = [];                 // 📚 Collection of all received error messages
        let realtimeConnectionStatus = 'disconnected';  // 🚦 Current connection status
        
        /*
        🗂️ DATA MANAGEMENT SYSTEM - Keeping track of files and user choices
        ===================================================================
        
        These variables are like having different filing cabinets and clipboards
        to keep track of what the user is doing and what files they're working with.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like managing homework assignments or organizing photos:
        - selectedFile = the current assignment you're working on
        - selectedFiles = all the assignments you need to complete
        - fileQueue = the order you'll work on them
        - lastProcessedData = keeping the results so you can reference them later
        */
        let selectedFile = null;                 // 📄 Currently active file
        let selectedFiles = [];                  // 📁 All uploaded files  
        let currentFileIndex = 0;                // 🔢 Which file we're currently viewing
        let lastProcessedData = null;            // 💾 Store results for live filtering
        let fileQueue = [];                      // 📋 Queue for multiple files
        let activeTab = null;                    // 🗂️ Currently selected tab/view
        
        /*
        📡 REAL-TIME MONITORING SETUP - Establishing live communication with server
        ===========================================================================
        
        This function sets up our "radio tower" that maintains a constant connection
        to the Debuggle server, allowing us to receive error notifications instantly
        as they happen, like having a live news feed or stock ticker.
        
        🏆 HIGH SCHOOL EXPLANATION:
        Think of this like setting up a live stream or video call:
        1. Figure out the right "phone number" (WebSocket URL)
        2. Place the call (create WebSocket connection)
        3. Set up what to do when the call connects (onopen)
        4. Set up what to do when messages arrive (onmessage)
        5. Handle any connection problems (error handling)
        
        Once this is working, our dashboard can show live updates without the
        user having to refresh the page, like notifications on your phone.
        */
        function initRealtimeMonitoring() {
            // 🌐 SMART URL BUILDING - automatically use secure connection if needed
            // Like automatically switching between regular phone calls and encrypted calls
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/errors`;
            
            // 📞 ESTABLISH CONNECTION - "dial the server" to start live communication
            // Like placing a video call or starting a live stream
            websocket = new WebSocket(wsUrl);
            
            /*
            ✅ CONNECTION SUCCESS HANDLER - what to do when we get connected
            
            This is like the "call connected" notification - we update our status
            display to show users that live monitoring is now active.
            */
            websocket.onopen = function(event) {
                console.log('Real-time error monitoring connected');   // 📝 Developer log message
                realtimeConnectionStatus = 'connected';               // 🚦 Update our status tracker
                updateConnectionStatus();                             // 🔄 Update the UI display
            };
            
            /*
            📨 MESSAGE HANDLER - what to do when new error data arrives
            
            This is like having a notification handler on your phone - when a new
            message arrives, we need to process it and update our display.
            */
            websocket.onmessage = function(event) {
                try {
                    // 📦 UNPACK THE MESSAGE - convert from text to usable data
                    // Like opening an envelope and reading the contents
                    const data = JSON.parse(event.data);
                    handleRealtimeMessage(data);                      // 🎯 Process the error data
                } catch (error) {
                    // 🚨 HANDLE CORRUPTED MESSAGES - deal with garbled data gracefully
                    console.error('Error parsing WebSocket message:', error);
                }
            };
            
            websocket.onclose = function(event) {
                console.log('Real-time error monitoring disconnected');
                realtimeConnectionStatus = 'disconnected';
                updateConnectionStatus();
                
                // Attempt to reconnect after 5 seconds
                setTimeout(() => {
                    if (realtimeConnectionStatus === 'disconnected') {
                        initRealtimeMonitoring();
                    }
                }, 5000);
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                realtimeConnectionStatus = 'error';
                updateConnectionStatus();
            };
        }
        
        function handleRealtimeMessage(data) {
            switch (data.type) {
                case 'welcome':
                    console.log('Real-time monitoring:', data.message);
                    if (data.recent_errors) {
                        realtimeErrors = data.recent_errors;
                        updateRealtimeErrorsDisplay();
                    }
                    break;
                    
                case 'error':
                    // New error reported
                    const errorEvent = {
                        id: data.id,
                        timestamp: data.timestamp,
                        error_type: data.error_type,
                        message: data.message,
                        source: data.source,
                        severity: data.severity,
                        metadata: data.metadata
                    };
                    realtimeErrors.unshift(errorEvent);
                    
                    // Keep only last 50 errors
                    if (realtimeErrors.length > 50) {
                        realtimeErrors = realtimeErrors.slice(0, 50);
                    }
                    
                    updateRealtimeErrorsDisplay();
                    showRealtimeErrorNotification(errorEvent);
                    break;
                    
                case 'self_monitoring_error':
                    // Debuggle's own internal error
                    console.warn('🐞 Debuggle Internal Error:', data.error);
                    showSelfMonitoringError(data.error);
                    break;
                    
                case 'stats_update':
                    console.log('Error stats updated:', data.error_stats);
                    break;
                    
                case 'monitoring_status':
                    console.log('Monitoring status:', data.message);
                    break;
                    
                case 'pong':
                    // Keep-alive response
                    break;
                    
                default:
                    console.log('Unknown realtime message:', data);
            }
        }
        
        function updateConnectionStatus() {
            // You could add a status indicator to the UI here
            const statusColors = {
                'connected': '#4caf50',
                'disconnected': '#f44336',
                'error': '#ff9800'
            };
            
            // Update header background color slightly to indicate connection status
            document.querySelector('.header').style.borderBottom = 
                `3px solid ${statusColors[realtimeConnectionStatus]}`;
        }
        
        function updateRealtimeErrorsDisplay() {
            // This could be enhanced to show recent errors in a sidebar or notification area
            console.log(`${realtimeErrors.length} real-time errors tracked`);
        }
        
        function showRealtimeErrorNotification(errorEvent) {
            // Create a temporary notification for new errors
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff6b35;
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
                z-index: 1000;
                max-width: 300px;
                animation: slideInRight 0.3s ease-out;
            `;
            
            notification.innerHTML = `
                <strong>🚨 ${errorEvent.error_type}</strong><br>
                <small>${errorEvent.message.substring(0, 100)}${errorEvent.message.length > 100 ? '...' : ''}</small>
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }
        
        function showSelfMonitoringError(error) {
            // Create a special notification for Debuggle's own errors
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
                color: white;
                padding: 20px;
                border-radius: 15px;
                box-shadow: 0 8px 24px rgba(255, 71, 87, 0.4);
                z-index: 1001;
                max-width: 400px;
                border-left: 5px solid #fff;
                animation: slideInRight 0.3s ease-out;
            `;
            
            const timestamp = new Date(error.timestamp).toLocaleTimeString();
            const contextInfo = error.context ? ` (${error.context})` : '';
            const endpointInfo = error.endpoint ? ` at ${error.endpoint}` : '';
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 1.5em; margin-right: 10px;">🐞</span>
                    <strong>Debuggle Internal Error</strong>
                </div>
                <div style="margin-bottom: 8px;">
                    <strong>${error.error_type}</strong>${contextInfo}${endpointInfo}
                </div>
                <div style="font-size: 0.9em; margin-bottom: 8px; opacity: 0.9;">
                    ${error.message.substring(0, 150)}${error.message.length > 150 ? '...' : ''}
                </div>
                <div style="font-size: 0.8em; opacity: 0.7;">
                    ${timestamp} • Source: ${error.source}
                </div>
                ${error.traceback ? `
                    <details style="margin-top: 10px; font-size: 0.8em;">
                        <summary style="cursor: pointer; opacity: 0.8;">View Traceback</summary>
                        <pre style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.7em; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${error.traceback}</pre>
                    </details>
                ` : ''}
            `;
            
            document.body.appendChild(notification);
            
            // Add click to dismiss
            notification.style.cursor = 'pointer';
            notification.onclick = () => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            };
            
            // Auto-remove after 10 seconds (longer for self-monitoring errors)
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 10000);
        }
        
        function sendWebSocketMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(message));
            }
        }
        
        // Self-monitoring functionality
        let selfMonitoringEnabled = false;
        
        function toggleSelfMonitoringPanel() {
            const panel = document.getElementById('selfMonitoringSection');
            const button = document.getElementById('showSelfMonitoring');
            
            if (panel.style.display === 'none' || !panel.style.display) {
                panel.style.display = 'block';
                button.textContent = '🔧 Hide Developer Tools';
                // Load initial status
                refreshSelfMonitoringStatus();
            } else {
                panel.style.display = 'none';
                button.textContent = '🔧 Developer Tools';
            }
        }
        
        async function toggleSelfMonitoring() {
            const newState = !selfMonitoringEnabled;
            
            try {
                const response = await fetch('/api/v1/self-monitor/toggle', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ enabled: newState })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    selfMonitoringEnabled = result.enabled;
                    updateSelfMonitoringToggleButton();
                    refreshSelfMonitoringStatus();
                } else {
                    console.error('Failed to toggle self-monitoring');
                }
            } catch (error) {
                console.error('Error toggling self-monitoring:', error);
            }
        }
        
        function updateSelfMonitoringToggleButton() {
            const button = document.getElementById('selfMonitoringToggle');
            button.textContent = selfMonitoringEnabled ? 'Disable Monitoring' : 'Enable Monitoring';
            button.style.background = selfMonitoringEnabled ? 
                'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
        }
        
        async function refreshSelfMonitoringStatus() {
            try {
                const response = await fetch('/api/v1/self-monitor/status');
                if (response.ok) {
                    const data = await response.json();
                    
                    document.getElementById('monitoringStatusText').textContent = 
                        data.monitoring_enabled ? 'Active' : 'Inactive';
                    document.getElementById('errorCountText').textContent = 
                        data.total_errors;
                    
                    selfMonitoringEnabled = data.monitoring_enabled;
                    updateSelfMonitoringToggleButton();
                    
                    // Display recent errors
                    displaySelfMonitoringErrors(data.recent_errors);
                }
            } catch (error) {
                console.error('Error refreshing self-monitoring status:', error);
            }
        }
        
        function displaySelfMonitoringErrors(errors) {
            const container = document.getElementById('selfMonitoringErrors');
            
            if (!errors || errors.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No recent errors</p>';
                return;
            }
            
            container.innerHTML = errors.map(error => {
                const timestamp = new Date(error.timestamp).toLocaleString();
                const contextInfo = error.context ? ` (${error.context})` : '';
                const endpointInfo = error.endpoint ? ` at ${error.endpoint}` : '';
                
                return `
                    <div class="self-error-item">
                        <div class="self-error-header">
                            <span class="self-error-type">${error.error_type}${contextInfo}${endpointInfo}</span>
                            <span class="self-error-time">${timestamp}</span>
                        </div>
                        <div class="self-error-message">${error.message}</div>
                        ${error.source ? `<div class="self-error-context">Source: ${error.source}</div>` : ''}
                        ${error.traceback ? `
                            <details style="margin-top: 10px;">
                                <summary style="cursor: pointer; color: #c44569;">View Traceback</summary>
                                <pre style="margin-top: 8px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 0.8em; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${error.traceback}</pre>
                            </details>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        async function clearSelfMonitoringErrors() {
            try {
                const response = await fetch('/api/v1/self-monitor/clear', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    refreshSelfMonitoringStatus();
                } else {
                    console.error('Failed to clear self-monitoring errors');
                }
            } catch (error) {
                console.error('Error clearing self-monitoring errors:', error);
            }
        }
        
        async function testSelfMonitoring() {
            try {
                const response = await fetch('/api/v1/self-monitor/test-error', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Refresh status to show the new test error
                    setTimeout(() => refreshSelfMonitoringStatus(), 500);
                } else {
                    console.error('Failed to generate test error');
                }
            } catch (error) {
                console.error('Error generating test error:', error);
            }
        }
        
        // Start real-time monitoring when page loads
        window.addEventListener('load', function() {
            initRealtimeMonitoring();
            
            // Send periodic pings to keep connection alive
            setInterval(() => {
                sendWebSocketMessage({ type: 'ping' });
            }, 30000);
        });

        // Drag and drop functionality
        dragDropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dragDropArea.classList.add('drag-over');
        });

        dragDropArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragDropArea.classList.remove('drag-over');
        });

        dragDropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dragDropArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFiles(Array.from(files));
            }
        });

        dragDropArea.addEventListener('click', (e) => {
            // Only trigger file input if not clicking on the button
            if (!e.target.closest('button')) {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
                // Clear the input value to allow selecting the same file again
                e.target.value = '';
            }
        });

        function handleFiles(files) {
            // Reset UI
            hideError();
            hideResults();
            
            if (files.length === 1) {
                // Single file: auto-process immediately
                selectedFile = files[0];
                showFilePreview(files[0]);
                // Auto-process after a brief delay to show the preview
                setTimeout(() => {
                    processFile();
                }, 500);
            } else {
                // Multiple files: show selection and require manual processing
                selectedFiles = files;
                showMultipleFilePreview(files);
            }
        }

        function handleFile(file) {
            // Backward compatibility - convert single file to array
            handleFiles([file]);
        }

        function showFilePreview(file) {
            // Update drag drop area appearance
            dragDropArea.classList.add('file-selected');
            
            // Update file details - show it's auto-processing
            fileName.textContent = file.name;
                    fileSize.textContent = `${formatFileSize(file.size)} • ${getFileIcon(file.name)} Auto-analyzing...`;            // Show file preview section
            filePreview.classList.add('show');
            
            // Reset action buttons - hide process button since it's auto-processing
            uploadSuccess.style.display = 'none';
            processBtn.style.display = 'none';
            processBtn.textContent = 'Process File';
            processBtn.disabled = false;
            
            // Scroll to show the file preview
            filePreview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function showMultipleFilePreview(files) {
            // Update drag drop area appearance
            dragDropArea.classList.add('file-selected');
            hideResults();
            
            // Initialize file queue
            fileQueue = files.map((file, index) => ({
                id: `file_${Date.now()}_${index}`,
                file: file,
                status: 'pending', // pending, processing, completed, error
                data: null,
                error: null
            }));
            
            // Hide single file preview, show file queue
            filePreview.classList.remove('show');
            
            // Create and show file queue UI
            createFileQueueUI();
            
            // Scroll to show the file queue
            document.getElementById('fileQueue').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function createFileQueueUI() {
            const pendingCount = fileQueue.filter(f => f.status === 'pending').length;
            const fileQueueHtml = `
                <div class="file-queue show" id="fileQueue">
                    <div class="queue-header">
                        <h3>📁 Multiple Files Ready for Analysis</h3>
                        <p>Review your files below and analyze them individually or all at once.</p>
                    </div>
                    <div class="queue-actions">
                        <button class="btn-primary" onclick="processAllFiles()" id="processAllBtn">
                            🚀 Process All ${pendingCount} Files
                        </button>
                        <button class="btn-secondary" onclick="removeFile()">
                            🗑️ Clear All Files
                        </button>
                    </div>
                    <div class="file-list" id="fileList">
                        ${fileQueue.map(item => createFileItemHTML(item)).join('')}
                    </div>
                    <div class="file-tabs" id="fileTabs" style="display: none;"></div>
                    <div class="tab-contents" id="tabContents"></div>
                </div>
            `;
            
            // Insert after the main upload section
            const uploadSection = document.querySelector('.upload-section');
            const existingQueue = document.getElementById('fileQueue');
            if (existingQueue) {
                existingQueue.remove();
            }
            uploadSection.insertAdjacentHTML('afterend', fileQueueHtml);
        }

        function createFileItemHTML(item) {
            const statusIcons = {
                pending: '⏳',
                processing: '🔄',
                completed: '✅',
                error: '❌'
            };
            
            const statusClass = item.status;
            const statusText = item.status.charAt(0).toUpperCase() + item.status.slice(1);
            
            return `
                <div class="file-item ${statusClass}" id="${item.id}">
                    <div class="file-info-left">
                        <div class="file-icon-large">${getFileIcon(item.file.name)}</div>
                        <div class="file-details-multi">
                            <h4>${item.file.name}</h4>
                            <p>${formatFileSize(item.file.size)} • ${statusIcons[item.status]} ${statusText}</p>
                        </div>
                    </div>
                    <div class="file-actions-multi">
                        ${item.status === 'pending' ? `<button class="btn-small" onclick="processSingleFileFromQueue('${item.id}')">Process</button>` : ''}
                        ${item.status === 'completed' ? `<button class="btn-small" onclick="viewFileResults('${item.id}')">View Results</button>` : ''}
                        <button class="btn-small btn-remove" onclick="removeFileFromQueue('${item.id}')">Remove</button>
                    </div>
                </div>
            `;
        }

        function processFile() {
            if (selectedFiles.length > 0) {
                // Process multiple files
                processMultipleFiles();
            } else if (selectedFile) {
                // Process single file
                processSingleFile(selectedFile);
            }
        }

        function processSingleFile(file) {
            // Show processing state
            showProgress();
            
            // Create form data
            const formData = new FormData();
            formData.append('file', file);
            formData.append('language', 'auto'); // Always auto-detect
            formData.append('highlight', document.getElementById('highlight').checked);
            formData.append('summarize', document.getElementById('summarize').checked);
            formData.append('tags', document.getElementById('tags').checked);
            formData.append('max_lines', '1000'); // Default to 1000 lines

            // Upload and process file
            fetch('/api/v1/upload-log', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                // Store data for live filtering
                lastProcessedData = data;
                
                // Show success state
                uploadSuccess.style.display = 'flex';
                
                // Update file size display
                fileSize.textContent = `${formatFileSize(file.size)} • ${getFileIcon(file.name)} Processed successfully!`;
                
                // Display results
                displayResults(data);
            })
            .catch(error => {
                console.error('Error:', error);
                showError(error.detail?.error || 'An error occurred while analyzing the file.');
                
                // Reset file size display
                fileSize.textContent = `${formatFileSize(file.size)} • ${getFileIcon(file.name)} Analysis failed`;
            })
            .finally(() => {
                hideProgress();
            });
        }

        function processMultipleFiles() {
            if (selectedFiles.length === 0) return;
            
            // Show processing state
            processBtn.textContent = 'Analyzing...';
            processBtn.disabled = true;
            showProgress();
            
            currentFileIndex = 0;
            const allResults = [];
            
            // Process files sequentially
            processNextFile(allResults);
        }

        function processNextFile(allResults) {
            if (currentFileIndex >= selectedFiles.length) {
                // All files processed - combine results
                displayMultipleResults(allResults);
                
                // Update UI
                uploadSuccess.style.display = 'flex';
                processBtn.textContent = 'Reprocess All';
                processBtn.disabled = false;
                hideProgress();
                return;
            }
            
            const file = selectedFiles[currentFileIndex];
                fileName.textContent = `Analyzing: ${file.name} (${currentFileIndex + 1}/${selectedFiles.length})`;            // Create form data
            const formData = new FormData();
            formData.append('file', file);
            formData.append('language', 'auto');
            formData.append('highlight', document.getElementById('highlight').checked);
            formData.append('summarize', document.getElementById('summarize').checked);
            formData.append('tags', document.getElementById('tags').checked);
            formData.append('max_lines', '1000');

            // Process current file
            fetch('/api/v1/upload-log', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                // Add file info to results
                data.filename = file.name;
                allResults.push(data);
                
                // Process next file
                currentFileIndex++;
                processNextFile(allResults);
            })
            .catch(error => {
                console.error('Error processing', file.name, ':', error);
                
                // Add error result
                allResults.push({
                    filename: file.name,
                    error: error.detail?.error || 'Processing failed',
                    cleaned_log: '',
                    summary: '',
                    tags: [],
                    metadata: { filename: file.name, file_size: file.size }
                });
                
                // Process next file
                currentFileIndex++;
                processNextFile(allResults);
            });
        }

        function removeFile() {
            // Clear selected files
            selectedFile = null;
            selectedFiles = [];
            currentFileIndex = 0;
            
            // Reset UI
            dragDropArea.classList.remove('file-selected');
            filePreview.classList.remove('show');
            hideResults();
            hideError();
            
            // Reset file input
            fileInput.value = '';
        }

        function displayMultipleResults(allResults) {
            // Store data for live filtering
            lastProcessedData = { 
                type: 'multiple', 
                results: allResults 
            };
            
            // Show results section
            resultsSection.style.display = 'block';
            
            // Combine all logs with file separators
            let combinedLog = '';
            let allTags = new Set();
            let successCount = 0;
            let errorCount = 0;
            
            allResults.forEach((result, index) => {
                if (result.error) {
                    combinedLog += `\n📁 File: ${result.filename}\n❌ Error: ${result.error}\n\n`;
                    errorCount++;
                } else {
                    combinedLog += `\n📁 File: ${result.filename}\n${result.cleaned_log}\n\n`;
                    if (result.tags) {
                        result.tags.forEach(tag => allTags.add(tag));
                    }
                    successCount++;
                }
            });
            
            // Apply live filtering based on current toggle states
            const showSummary = document.getElementById('summarize').checked;
            const showTags = document.getElementById('tags').checked;
            const showFormatting = document.getElementById('highlight').checked;
            
            // Display combined results with conditional formatting
            if (showFormatting) {
                const formattedLog = formatLogOutput(combinedLog);
                resultsContent.innerHTML = formattedLog;
                resultsContent.classList.remove('plain-mode');
            } else {
                const plainLog = formatPlainLogOutput(combinedLog);
                resultsContent.innerHTML = plainLog;
                resultsContent.classList.add('plain-mode');
            }
            
            // Create combined summary
            const combinedSummary = `Processed ${allResults.length} files: ${successCount} successful, ${errorCount} failed. ` +
                (successCount > 0 ? allResults.filter(r => !r.error).map(r => r.summary).filter(s => s).join(' | ') : '');
            
            if (showSummary && combinedSummary) {
                summarySection.style.display = 'block';
                summaryContent.textContent = combinedSummary;
            } else {
                summarySection.style.display = 'none';
            }
            
            // Display combined tags
            if (showTags && allTags.size > 0) {
                tagsSection.style.display = 'block';
                tagsContent.innerHTML = Array.from(allTags).map((tag, index) => 
                    `<span class="tag" onclick="toggleTagHighlight('${escapeHtml(tag)}', this)" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsSection.style.display = 'none';
            }
            
            // Display metadata for multiple files
            const totalSize = allResults.reduce((sum, result) => sum + (result.metadata?.file_size || 0), 0);
            const totalLines = allResults.reduce((sum, result) => sum + (result.metadata?.lines || 0), 0);
            
            metadataSection.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-value">${allResults.length}</div>
                    <div class="metadata-label">Files Processed</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${successCount}</div>
                    <div class="metadata-label">Successful</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${errorCount}</div>
                    <div class="metadata-label">Failed</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${formatFileSize(totalSize)}</div>
                    <div class="metadata-label">Total Size</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${totalLines}</div>
                    <div class="metadata-label">Total Lines</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">Live Filtered</div>
                    <div class="metadata-label">Processing Mode</div>
                </div>
            `;
        }

        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const icons = {
                'log': '📋',
                'txt': '📄',
                'err': '❌',
                'out': '📤',
                'json': '🔧',
                'py': '🐍',
                'js': '💛',
                'java': '☕',
                'xml': '📜'
            };
            return icons[ext] || '📄';
        }

        function showProgress() {
            progressBar.style.display = 'block';
            progressFill.style.width = '100%';
        }

        function hideProgress() {
            progressBar.style.display = 'none';
            progressFill.style.width = '0%';
        }

        function displayResults(data) {
            // Show results section
            resultsSection.style.display = 'block';
            
            // Apply live filtering based on current toggle states
            const showSummary = document.getElementById('summarize').checked;
            const showTags = document.getElementById('tags').checked;
            const showFormatting = document.getElementById('highlight').checked;
            
            // Display cleaned log with conditional formatting
            if (showFormatting) {
                const formattedLog = formatLogOutput(data.cleaned_log);
                resultsContent.innerHTML = formattedLog;
                resultsContent.classList.remove('plain-mode');
            } else {
                // Plain text mode - no fancy formatting, just basic text
                const plainLog = formatPlainLogOutput(data.cleaned_log);
                resultsContent.innerHTML = plainLog;
                resultsContent.classList.add('plain-mode');
            }
            
            // Display summary conditionally
            if (showSummary && data.summary) {
                summarySection.style.display = 'block';
                summaryContent.textContent = data.summary;
            } else {
                summarySection.style.display = 'none';
            }
            
            // Display tags conditionally
            if (showTags && data.tags && data.tags.length > 0) {
                tagsSection.style.display = 'block';
                tagsContent.innerHTML = data.tags.map((tag, index) => 
                    `<span class="tag" onclick="toggleTagHighlight('${escapeHtml(tag)}', this)" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsSection.style.display = 'none';
            }
            
            // Display metadata
            const metadata = data.metadata;
            metadataSection.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.filename}</div>
                    <div class="metadata-label">Filename</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${formatFileSize(metadata.file_size)}</div>
                    <div class="metadata-label">File Size</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.lines}</div>
                    <div class="metadata-label">Lines</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.language_detected}</div>
                    <div class="metadata-label">Language</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.processing_time_ms}ms</div>
                    <div class="metadata-label">Processing Time</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">Live Filtered</div>
                    <div class="metadata-label">Processing Mode</div>
                </div>
            `;
        }

        function formatLogOutput(logText) {
            // Split into lines and format each one (ENHANCED MODE)
            const lines = logText.split('\n');
            const formattedLines = lines.map((line, index) => {
                if (!line.trim()) return '';
                
                // Determine which tags this line relates to
                const lineTags = getLineTagMapping(line);
                const tagDataAttr = lineTags.length > 0 ? `data-tags="${lineTags.join(',')}"` : '';
                
                // Color-code different types of messages
                let formattedLine = escapeHtml(line);
                
                // Style timestamps (look for "At HH:MM:SS AM/PM on Mon DD" pattern)
                formattedLine = formattedLine.replace(
                    /(At \d{1,2}:\d{2}:\d{2} (?:AM|PM) on \w{3} \d{1,2})/g, 
                    '<span class="timestamp">$1</span>'
                );
                
                // Style different emoji categories with tag data
                if (line.startsWith('❌')) {
                    return `<div class="log-error log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('🔒')) {
                    return `<div class="log-security log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('📁') || line.startsWith('📧')) {
                    return `<div class="log-warning log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('✅')) {
                    return `<div class="log-success log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('⚠️')) {
                    return `<div class="log-repeated log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('ℹ️')) {
                    return `<div class="log-info log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else {
                    return `<div class="log-normal log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                }
            });
            
            return formattedLines.join('');
        }

        function formatPlainLogOutput(logText) {
            // Split into lines and format with minimal styling (PLAIN MODE)
            const lines = logText.split('\n');
            const formattedLines = lines.map((line, index) => {
                if (!line.trim()) return '';
                
                // Determine which tags this line relates to (for tag highlighting to still work)
                const lineTags = getLineTagMapping(line);
                const tagDataAttr = lineTags.length > 0 ? `data-tags="${lineTags.join(',')}"` : '';
                
                // Simple escaped HTML - no fancy colors or styling
                let plainLine = escapeHtml(line);
                
                // Just basic line formatting without colors
                return `<div class="log-plain log-entry" ${tagDataAttr}>${plainLine}</div>`;
            });
            
            return formattedLines.join('');
        }

        function getLineTagMapping(line) {
            const tags = [];
            const lowerLine = line.toLowerCase();
            
            // Map line content to common API tags based on content patterns
            if (lowerLine.includes('connection') || lowerLine.includes('connect')) {
                tags.push('Connection Problems');
            }
            if (lowerLine.includes('database') || lowerLine.includes('db')) {
                tags.push('Database');
            }
            if (lowerLine.includes('error') || lowerLine.includes('exception') || lowerLine.includes('failed')) {
                tags.push('Serious Problems');
            }
            if (lowerLine.includes('critical') || lowerLine.includes('fatal')) {
                tags.push('Critical Error');
            }
            if (lowerLine.includes('warning') || lowerLine.includes('warn')) {
                tags.push('Minor Warnings');
            }
            if (lowerLine.includes('timeout') || lowerLine.includes('slow')) {
                tags.push('Slow Response');
            }
            if (lowerLine.includes('password') || lowerLine.includes('login') || lowerLine.includes('auth')) {
                tags.push('Login Issues');
            }
            if (lowerLine.includes('file') || lowerLine.includes('directory')) {
                tags.push('File Problems');
            }
            if (lowerLine.includes('python') && (lowerLine.includes('traceback') || lowerLine.includes('exception'))) {
                tags.push('Python');
            }
            if (lowerLine.includes('stack trace') || lowerLine.includes('traceback')) {
                tags.push('Stack Trace');
            }
            if (lowerLine.includes('attribute') && lowerLine.includes('error')) {
                tags.push('AttributeError');
            }
            if (lowerLine.includes('needs attention') || lowerLine.includes('developer attention')) {
                tags.push('Needs Attention');
                tags.push('Needs Developer Attention');
            }
            if (lowerLine.includes('programming') && lowerLine.includes('bug')) {
                tags.push('Programming Bug');
            }
            
            return tags;
        }

        let activeTagFilter = null;

        function toggleTagHighlight(tagName, tagElement) {
            // Remove existing highlights
            document.querySelectorAll('.log-entry.highlighted').forEach(entry => {
                entry.classList.remove('highlighted');
            });
            
            // Remove active state from all tags
            document.querySelectorAll('.tag.active').forEach(tag => {
                tag.classList.remove('active');
            });
            
            // If clicking the same tag, clear the filter
            if (activeTagFilter === tagName) {
                activeTagFilter = null;
                return;
            }
            
            // Set new active tag
            activeTagFilter = tagName;
            tagElement.classList.add('active');
            
            // Highlight matching log entries
            let firstMatch = null;
            document.querySelectorAll('.log-entry').forEach(entry => {
                const entryTags = entry.getAttribute('data-tags');
                if (entryTags && entryTags.split(',').includes(tagName)) {
                    entry.classList.add('highlighted');
                    // Track first match for scrolling
                    if (!firstMatch) {
                        firstMatch = entry;
                    }
                }
            });
            
            // Scroll first match into view
            if (firstMatch) {
                firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function liveReprocess() {
            if (!lastProcessedData) return;
            
            // Add visual feedback
            showLiveProcessingIndicator();
            
            // Small delay to show the processing indicator
            setTimeout(() => {
                if (lastProcessedData.type === 'multiple') {
                    displayMultipleResults(lastProcessedData.results);
                } else {
                    displayResults(lastProcessedData);
                }
                hideLiveProcessingIndicator();
            }, 200);
        }

        function stripFormatting(text) {
            // Remove any formatting/styling from the text for plain display
            return text.replace(/\033\[[0-9;]*m/g, ''); // Remove ANSI codes if any
        }

        function showLiveProcessingIndicator() {
            // Add a subtle processing overlay
            resultsContent.style.opacity = '0.6';
            resultsContent.style.transition = 'opacity 0.2s ease';
            
            // Update metadata to show live processing
            const lastMetadataItem = metadataSection.querySelector('.metadata-item:last-child');
            if (lastMetadataItem) {
                const valueDiv = lastMetadataItem.querySelector('.metadata-value');
                if (valueDiv) {
                    valueDiv.textContent = 'Live Processing...';
                    valueDiv.style.color = '#ff6b35';
                }
            }
        }

        function hideLiveProcessingIndicator() {
            // Remove processing overlay
            resultsContent.style.opacity = '1';
            
            // Reset metadata styling
            const lastMetadataItem = metadataSection.querySelector('.metadata-item:last-child');
            if (lastMetadataItem) {
                const valueDiv = lastMetadataItem.querySelector('.metadata-value');
                if (valueDiv) {
                    valueDiv.textContent = 'Live Filtered';
                    valueDiv.style.color = '#2a5298';
                }
            }
        }

        function processSingleFileFromQueue(fileId) {
            const fileItem = fileQueue.find(item => item.id === fileId);
            if (!fileItem) return;
            
            // Update status
            fileItem.status = 'processing';
            updateFileItemDisplay(fileItem);
            
            // Create form data
            const formData = new FormData();
            formData.append('file', fileItem.file);
            formData.append('language', 'auto');
            formData.append('highlight', document.getElementById('highlight').checked);
            formData.append('summarize', document.getElementById('summarize').checked);
            formData.append('tags', document.getElementById('tags').checked);
            formData.append('max_lines', '1000');

            fetch('/api/v1/upload-log', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                // Store results
                fileItem.data = data;
                fileItem.status = 'completed';
                updateFileItemDisplay(fileItem);
                
                // Create tab for this file
                createFileTab(fileItem);
            })
            .catch(error => {
                console.error('Error processing', fileItem.file.name, ':', error);
                fileItem.error = error.detail?.error || 'Processing failed';
                fileItem.status = 'error';
                updateFileItemDisplay(fileItem);
            });
        }

        function processAllFiles() {
            const pendingFiles = fileQueue.filter(item => item.status === 'pending');
            const processAllBtn = document.getElementById('processAllBtn');
            
            if (pendingFiles.length === 0) return;
            
            processAllBtn.textContent = `Processing ${pendingFiles.length} files...`;
            processAllBtn.disabled = true;
            
            // Process files sequentially
            let currentIndex = 0;
            
            function processNext() {
                if (currentIndex >= pendingFiles.length) {
                    processAllBtn.textContent = 'All Files Processed!';
                    setTimeout(() => {
                        processAllBtn.textContent = `🚀 Process All ${fileQueue.filter(f => f.status === 'pending').length} Files`;
                        processAllBtn.disabled = false;
                    }, 2000);
                    return;
                }
                
                const fileItem = pendingFiles[currentIndex];
                processSingleFileFromQueue(fileItem.id);
                
                // Wait a bit then process next
                setTimeout(() => {
                    currentIndex++;
                    processNext();
                }, 1000);
            }
            
            processNext();
        }

        function updateFileItemDisplay(fileItem) {
            const element = document.getElementById(fileItem.id);
            if (!element) return;
            
            element.className = `file-item ${fileItem.status}`;
            element.innerHTML = createFileItemHTML(fileItem).replace(/^<div[^>]*>|<\/div>$/g, '');
        }

        function removeFileFromQueue(fileId) {
            const index = fileQueue.findIndex(item => item.id === fileId);
            if (index > -1) {
                // Remove tab if exists
                const tab = document.getElementById(`tab_${fileId}`);
                if (tab) {
                    if (tab.classList.contains('active')) {
                        // Switch to another tab or hide results
                        const otherTabs = document.querySelectorAll('.file-tab');
                        if (otherTabs.length > 1) {
                            const nextTab = Array.from(otherTabs).find(t => t.id !== `tab_${fileId}`);
                            if (nextTab) {
                                switchToTab(nextTab.id.replace('tab_', ''));
                            }
                        } else {
                            hideResults();
                        }
                    }
                    tab.remove();
                    document.getElementById(`content_${fileId}`).remove();
                }
                
                fileQueue.splice(index, 1);
                document.getElementById(fileId).remove();
                
                // Update process all button
                const processAllBtn = document.getElementById('processAllBtn');
                if (processAllBtn) {
                    const pendingCount = fileQueue.filter(f => f.status === 'pending').length;
                    processAllBtn.textContent = `🚀 Process All ${pendingCount} Files`;
                }
                
                // Hide queue if empty
                if (fileQueue.length === 0) {
                    document.getElementById('fileQueue').remove();
                    removeFile(); // Reset to initial state
                }
            }
        }

        function createFileTab(fileItem) {
            const tabsContainer = document.getElementById('fileTabs');
            const tabContents = document.getElementById('tabContents');
            
            // Show tabs if hidden
            tabsContainer.style.display = 'flex';
            
            // Create tab
            const tab = document.createElement('button');
            tab.className = 'file-tab';
            tab.id = `tab_${fileItem.id}`;
            tab.textContent = fileItem.file.name;
            tab.onclick = () => switchToTab(fileItem.id);
            tabsContainer.appendChild(tab);
            
            // Create tab content
            const tabContent = document.createElement('div');
            tabContent.className = 'tab-content';
            tabContent.id = `content_${fileItem.id}`;
            tabContents.appendChild(tabContent);
            
            // Populate content
            populateTabContent(fileItem, tabContent);
            
            // Switch to this tab
            switchToTab(fileItem.id);
        }

        function switchToTab(fileId) {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.file-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Activate selected tab and content
            const tab = document.getElementById(`tab_${fileId}`);
            const content = document.getElementById(`content_${fileId}`);
            
            if (tab && content) {
                tab.classList.add('active');
                content.classList.add('active');
                activeTab = fileId;
                
                // Update live filtering for this tab's content
                const fileItem = fileQueue.find(item => item.id === fileId);
                if (fileItem && fileItem.data) {
                    lastProcessedData = fileItem.data;
                }
            }
        }

        function populateTabContent(fileItem, tabElement) {
            // Create individual results section for this file
            tabElement.innerHTML = `
                <div class="results-section" style="display: block; margin: 0;">
                    <div class="summary-section" id="summarySection_${fileItem.id}" style="display: none;">
                        <div class="summary-header">🧠 Smart Analysis</div>
                        <div id="summaryContent_${fileItem.id}"></div>
                    </div>
                    
                    <div class="tags-section" id="tagsSection_${fileItem.id}" style="display: none;">
                        <strong>Tags:</strong>
                        <div id="tagsContent_${fileItem.id}"></div>
                    </div>
                    
                    <div class="results-header">
                        <strong>🔍 Analyzed Log Output</strong>
                    </div>
                    <div class="results-content" id="resultsContent_${fileItem.id}"></div>
                    
                    <div class="metadata-section" id="metadataSection_${fileItem.id}"></div>
                </div>
            `;
            
            // Populate with data
            displayResultsInTab(fileItem);
        }

        function displayResultsInTab(fileItem) {
            const data = fileItem.data;
            if (!data) return;
            
            const showSummary = document.getElementById('summarize').checked;
            const showTags = document.getElementById('tags').checked;
            const showFormatting = document.getElementById('highlight').checked;
            
            const resultsContent = document.getElementById(`resultsContent_${fileItem.id}`);
            const summarySection = document.getElementById(`summarySection_${fileItem.id}`);
            const summaryContent = document.getElementById(`summaryContent_${fileItem.id}`);
            const tagsSection = document.getElementById(`tagsSection_${fileItem.id}`);
            const tagsContent = document.getElementById(`tagsContent_${fileItem.id}`);
            const metadataSection = document.getElementById(`metadataSection_${fileItem.id}`);
            
            // Display formatted log
            if (showFormatting) {
                const formattedLog = formatLogOutput(data.cleaned_log);
                resultsContent.innerHTML = formattedLog;
                resultsContent.classList.remove('plain-mode');
            } else {
                const plainLog = formatPlainLogOutput(data.cleaned_log);
                resultsContent.innerHTML = plainLog;
                resultsContent.classList.add('plain-mode');
            }
            
            // Display summary conditionally
            if (showSummary && data.summary) {
                summarySection.style.display = 'block';
                summaryContent.textContent = data.summary;
            } else {
                summarySection.style.display = 'none';
            }
            
            // Display tags conditionally
            if (showTags && data.tags && data.tags.length > 0) {
                tagsSection.style.display = 'block';
                tagsContent.innerHTML = data.tags.map((tag, index) => 
                    `<span class="tag" onclick="toggleTagHighlight('${escapeHtml(tag)}', this)" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsSection.style.display = 'none';
            }
            
            // Display metadata
            const metadata = data.metadata;
            metadataSection.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.filename}</div>
                    <div class="metadata-label">Filename</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${formatFileSize(metadata.file_size)}</div>
                    <div class="metadata-label">File Size</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.lines}</div>
                    <div class="metadata-label">Lines</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.language_detected}</div>
                    <div class="metadata-label">Language</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.processing_time_ms}ms</div>
                    <div class="metadata-label">Processing Time</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">Individual</div>
                    <div class="metadata-label">Processing Mode</div>
                </div>
            `;
        }

        function viewFileResults(fileId) {
            const fileItem = fileQueue.find(item => item.id === fileId);
            if (fileItem && fileItem.data) {
                // Create tab if it doesn't exist
                if (!document.getElementById(`tab_${fileId}`)) {
                    createFileTab(fileItem);
                } else {
                    switchToTab(fileId);
                }
            }
        }

        function hideResults() {
            resultsSection.style.display = 'none';
            // Hide tabs as well
            const fileTabs = document.getElementById('fileTabs');
            if (fileTabs) {
                fileTabs.style.display = 'none';
            }
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function toggleOption(optionId, buttonElement) {
            const checkbox = document.getElementById(optionId);
            const isCurrentlyChecked = checkbox.checked;
            
            // Toggle the checkbox state
            checkbox.checked = !isCurrentlyChecked;
            
            // Update button appearance
            if (checkbox.checked) {
                buttonElement.classList.add('active');
            } else {
                buttonElement.classList.remove('active');
            }
            
            // Trigger live reprocessing if we have processed data
            if (lastProcessedData) {
                liveReprocess();
            }
        }
    </script>
</body>
</html>