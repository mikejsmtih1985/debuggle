<!--
üé® DEBUGGLE WEB DASHBOARD - The Digital Control Center (2,700+ Lines!)
========================================================================

This HTML file creates the beautiful, interactive web interface for Debuggle's
error analysis system. Think of it as designing a modern, user-friendly 
control panel for a high-tech spacecraft or research facility.

üèÜ HIGH SCHOOL EXPLANATION:
Imagine you're building a professional website that looks like something from
a sci-fi movie - clean, modern, and powerful. This massive file contains three main parts:

1. üìã HTML STRUCTURE (Lines 1-1200) - Like the blueprint of a building, defining what goes where
2. üé® CSS STYLING (Lines 100-1100) - Like interior decorating, making everything look beautiful
3. ‚ö° JAVASCRIPT CODE (Lines 1200-2700) - Like the electrical system, making everything interactive

üåü KEY FEATURES IMPLEMENTED:
‚úÖ Drag & Drop File Upload - Intuitive file selection with visual feedback
‚úÖ Real-Time Progress Tracking - Live updates during file processing
‚úÖ WebSocket Communication - Instant error notifications without page refresh
‚úÖ Interactive Dashboard Elements - Buttons, toggles, and dynamic content
‚úÖ Responsive Design - Works perfectly on desktop, tablet, and mobile
‚úÖ Professional Styling - Modern gradients, shadows, and animations
‚úÖ Error Handling - Graceful recovery from problems and clear user feedback

üéØ MAJOR COMPONENTS EXPLAINED:
‚Ä¢ File Upload Zone - Drag & drop interface with hover effects and processing states
‚Ä¢ Progress Indicators - Visual feedback during file analysis operations  
‚Ä¢ Results Display - Formatted output with syntax highlighting and interactive tags
‚Ä¢ Real-Time Monitoring - WebSocket connection for live error notifications
‚Ä¢ Control Panels - User preferences and analysis options
‚Ä¢ Responsive Layout - Automatic adjustment for different screen sizes

EDUCATIONAL METAPHORS USED IN THIS FILE:
üèóÔ∏è Architecture & Construction - HTML structure like building blueprints
üé® Interior Design - CSS styling like decorating and furniture arrangement  
‚ö° Electrical Systems - JavaScript like wiring that makes everything work
üé≠ Theater Production - Event handling like stage cues and lighting
üöÄ Spacecraft Controls - Dashboard elements like mission control panels
üì° Communication Systems - WebSocket connections like radio/satellite links
üè≠ Factory Automation - File processing workflows like assembly lines

The goal is to make complex error analysis feel approachable and intuitive,
like using a well-designed mobile app instead of scary command-line tools.
-->

<!DOCTYPE html>
<!--
üìã DOCUMENT BLUEPRINT - Telling the browser what kind of web page this is

The DOCTYPE declaration is like putting a label on a blueprint that says
"This is a modern web page design using HTML5 standards." It ensures the
browser interprets our code correctly, like making sure an architect and
contractor are using the same measurement system.
-->

<html lang="en">
<!--
üåç LANGUAGE SETTINGS - Setting up international compatibility

The 'lang="en"' attribute tells browsers, screen readers, and search engines
that this page is written in English. It's like putting a language label
on a document so translation services know how to handle it properly.
-->

<head>
    <!--
    üß† PAGE BRAIN - The control center that browsers read first
    
    The <head> section is like the control room of our web page. Users don't
    see this directly, but it contains all the important instructions that
    tell the browser how to display and behave. Think of it like the backstage
    area of a theater production - essential for the show, but hidden from the audience.
    -->
    
    <!-- üî§ CHARACTER ENCODING - Making sure all text displays correctly -->
    <meta charset="UTF-8">
    <!--
    This tells the browser how to interpret text characters, including emojis,
    special symbols, and international characters. UTF-8 is like a universal
    translator that can handle almost any language or symbol.
    -->
    
    <!-- üì± MOBILE OPTIMIZATION - Making sure the page looks good on phones and tablets -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
    This magic line ensures our dashboard looks great on everything from
    giant desktop monitors to tiny phone screens. It's like having a responsive
    design that automatically adjusts, similar to how a good website should
    look perfect whether you're on a laptop or smartphone.
    -->
    
    <!-- üè∑Ô∏è PAGE TITLE - What appears in the browser tab -->
    <title>üêû Debuggle - Error Analysis Tool</title>
    <!--
    This is what users see in their browser tab and bookmarks. The bug emoji
    makes it instantly recognizable among dozens of open tabs, like having
    a distinctive logo on a storefront.
    -->
    
    <!--
    üé® STYLESHEET SECTION - The Interior Design Department
    ========================================================
    
    Everything between <style> tags is CSS (Cascading Style Sheets), which is
    like having a team of interior designers who decide how everything looks:
    colors, fonts, layouts, animations, and visual effects.
    
    üèÜ HIGH SCHOOL EXPLANATION:
    Think of CSS like decorating a house:
    - HTML is the house structure (walls, rooms, doors)
    - CSS is the decoration (paint colors, furniture, lighting)
    - JavaScript is the utilities (plumbing, electrical, smart home features)
    
    We'll use metaphors like interior design, architecture, and visual arts
    to explain how CSS creates beautiful, professional interfaces.
    -->
    <style>
        /*
        üßπ UNIVERSAL RESET - Starting with a clean slate
        ================================================
        
        This CSS rule applies to every single element on the page (that's what * means).
        It's like having a cleaning crew come through and remove all the default
        spacing and formatting that browsers add automatically.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Imagine you're redecorating a room. Before you can arrange your furniture
        exactly how you want it, you need to:
        1. Remove all existing furniture (margin: 0, padding: 0)
        2. Measure everything consistently (box-sizing: border-box)
        
        Without this reset, different browsers would display our page slightly
        differently, like having different sized rooms in different buildings.
        */
        * {
            margin: 0;          /* üìè Remove all outer spacing around elements */
            padding: 0;         /* üì¶ Remove all inner spacing inside elements */
            box-sizing: border-box;  /* üìê Make size calculations predictable and consistent */
        }

        /*
        üè† MAIN CANVAS - Setting up our page background and foundation
        =============================================================
        
        The body element is like the main canvas or stage where our entire
        interface will be painted. This is where we set the overall mood,
        color scheme, and basic layout foundation.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like setting up a photography studio:
        1. Choose the backdrop color/pattern (background gradient)
        2. Set up proper lighting (font choices for readability)  
        3. Arrange the space (padding, height settings)
        4. Make sure everything fits in the frame (min-height: 100vh)
        */
        body {
            /* üñãÔ∏è TYPOGRAPHY SETUP - Choosing the best fonts for readability */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /*
            This font stack is like having backup singers ready. The browser tries:
            1. Apple's system font (on Mac/iOS) - looks native and familiar
            2. Microsoft's Segoe UI (on Windows) - clean and professional  
            3. Roboto (on Android) - modern and readable
            4. Generic sans-serif as final backup - always works
            */
            
            /* üåà BACKGROUND MAGIC - Creating a beautiful color gradient */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            /*
            This creates a diagonal color fade from blue to purple, like a sunset
            or professional presentation background. The degrees (135deg) control
            the angle, and percentages (0%, 100%) control where colors transition.
            */
            
            /* üìê LAYOUT FOUNDATION - Setting up the basic page structure */
            min-height: 100vh;  /* üìè Ensure page fills the full viewport height (100vh = 100% of visible height) */
            padding: 20px;      /* üéØ Add breathing room around the edges */
        }

        /*
        üè¢ MAIN DASHBOARD CONTAINER - The control center housing
        =======================================================
        
        This creates the main "building" that houses our entire dashboard.
        Think of it like designing a modern office building or spacecraft
        control center that sits beautifully in the landscape.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Imagine you're an architect designing a high-tech control center:
        1. Size limits (max-width) - don't make it too wide for readability
        2. Centering (margin: 0 auto) - place it perfectly in the middle
        3. Clean background (white) - professional, neutral workspace
        4. Rounded corners (border-radius) - modern, friendly appearance
        5. Floating effect (box-shadow) - makes it appear to hover above background
        */
        .container {
            max-width: 1200px;                              /* üìè Maximum width prevents reading difficulty on huge screens */
            margin: 0 auto;                                 /* üéØ Center the container horizontally on the page */
            background: white;                              /* ü§ç Clean, professional workspace background */
            border-radius: 20px;                           /* üîò Smooth, modern rounded corners */
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);      /* ‚ú® Subtle shadow creates floating effect */
            overflow: hidden;                              /* üì¶ Ensure child elements stay within rounded corners */
        }

        /*
        üé™ DASHBOARD HEADER - The welcoming entrance and title area
        ==========================================================
        
        The header is like the impressive entrance lobby of our control center.
        It needs to make a great first impression and clearly communicate what
        this system does, like the marquee sign outside a theater.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like designing the entrance to a theme park or museum:
        1. Eye-catching colors (gradient background) - draws attention
        2. Clear branding (centered text) - tells people where they are  
        3. Professional spacing (padding) - gives content room to breathe
        4. Consistent color scheme - matches the overall design theme
        */
        .header {
            /* üåä HEADER BACKGROUND - Creating visual impact with color flow */
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            /*
            A darker blue gradient that complements our page background,
            like having coordinated colors in interior design. Creates
            a professional, trustworthy feeling like bank or tech company branding.
            */
            
            color: white;           /* ü§ç White text for maximum contrast and readability */
            padding: 30px;          /* üé≠ Generous spacing for an impressive, uncluttered look */
            text-align: center;     /* üéØ Center-align all header content for balance */
        }

        /*
        üì¢ MAIN TITLE STYLING - Making the page title stand out
        =======================================================
        
        The h1 (heading 1) is like the main sign or logo - it needs to be
        immediately visible and communicate the purpose of our tool.
        */
        .header h1 {
            font-size: 2.5em;      /* üìè Large, attention-grabbing size (2.5 times normal text) */
            margin-bottom: 10px;    /* üìê Small gap before the subtitle */
        }

        /*
        üí¨ SUBTITLE STYLING - Supporting information that explains our purpose
        ====================================================================
        
        The paragraph text provides context and description, like the tagline
        under a company logo or the subtitle on a movie poster.
        */
        .header p {
            font-size: 1.2em;      /* üìè Slightly larger than normal text for emphasis */
            opacity: 0.9;          /* üå´Ô∏è Slightly transparent for subtle, elegant effect */
        }

        /*
        üè¢ MAIN WORKSPACE - The primary working area of our dashboard
        ============================================================
        
        This is like the main floor of our control center where all the
        important work happens. It needs generous spacing so content
        doesn't feel cramped, like having a spacious office layout.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like the main area of a well-designed store or restaurant:
        - Plenty of space to move around comfortably (padding: 40px)
        - Clean, uncluttered feeling that focuses attention on important content
        - Professional spacing that makes everything feel organized and premium
        */
        .main-content {
            padding: 40px;      /* üé≠ Generous spacing creates a premium, comfortable feeling */
        }

        /*
        üìÅ FILE UPLOAD ZONE - The primary interaction area for users
        ===========================================================
        
        This section is like the reception desk or main service counter
        where users first interact with our system. It needs to be
        prominent and inviting, like the entrance to a helpful service.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like the main counter at a phone repair shop or
        copy center - it's where customers bring their "problems" (log files)
        to get help. The spacing ensures it stands out as the primary action area.
        */
        .upload-section {
            margin-bottom: 40px;    /* üìê Space separation from other sections below */
        }

        /*
        üéØ DRAG & DROP INTERFACE - The interactive file upload area
        ==========================================================
        
        This creates the main "drop zone" where users can drag files from
        their computer, like having a designated landing pad for incoming
        spacecraft or a collection box for important documents.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like designing a dropbox or collection bin that:
        1. Looks clearly different from regular content (dashed border)
        2. Feels interactive and clickable (rounded corners, hover effects)
        3. Gives visual feedback when users interact with it (color changes)
        4. Has plenty of space so it's easy to "hit the target"
        */
        .drag-drop-area {
            border: 3px dashed #ddd;        /* üì¶ Dashed border shows this is a "drop zone" */
            border-radius: 15px;            /* üîò Rounded corners feel modern and friendly */
            padding: 60px 20px;             /* üé≠ Generous padding makes target easy to hit */
            text-align: center;             /* üéØ Center all content for balanced appearance */
            transition: all 0.3s ease;      /* ‚ú® Smooth animation for all property changes */
            cursor: pointer;                /* üëÜ Show hand cursor to indicate clickability */
            background: #f8f9fa;            /* üå´Ô∏è Light gray background, subtle and clean */
        }

        /*
        üé® INTERACTIVE FEEDBACK - Visual responses to user actions
        =========================================================
        
        These rules create different visual states that give users immediate
        feedback about what's happening, like traffic lights or status indicators.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like a smart doorbell or gaming controller that lights up:
        1. Hover state - changes color when you move mouse over it
        2. Drag-over state - special color when dragging a file over it  
        3. Processing state - different color when actively working
        
        This makes the interface feel alive and responsive, like a good video game.
        */
        .drag-drop-area:hover,              /* üëÜ When user hovers mouse over the area */
        .drag-drop-area.drag-over {         /* üìÅ When user is dragging a file over it */
            border-color: #2a5298;          /* üîµ Change to blue border - "ready to receive" */
            background: #e3f2fd;            /* üíô Light blue background - "active and ready" */
        }

        .drag-drop-area.processing {        /* ‚öôÔ∏è When the system is actively processing files */
            border-color: #ff9800;          /* üü† Orange border - "working on it" */
            background: #fff3e0;            /* üß° Light orange background - "please wait" */
        }

        /*
        üìÅ UPLOAD ICON - The visual symbol that communicates purpose
        ===========================================================
        
        The folder emoji serves as an international symbol that immediately
        tells users "this is where files go," like having clear signage
        in an airport or universal symbols on appliances.
        */
        .upload-icon {
            font-size: 4em;                 /* üìè Large size makes it impossible to miss */
            margin-bottom: 20px;            /* üìê Space between icon and text */
            color: #666;                    /* üå´Ô∏è Neutral gray color, professional but friendly */
        }

        /*
        üí¨ PRIMARY INSTRUCTION TEXT - Clear, action-oriented guidance
        ============================================================
        
        This text tells users exactly what they can do, like having clear
        instructions on a vending machine or self-checkout kiosk.
        */
        .upload-text {
            font-size: 1.3em;              /* üìè Slightly larger for emphasis and readability */
            color: #666;                    /* üå´Ô∏è Consistent color scheme with icon */
            margin-bottom: 10px;            /* üìê Small gap before secondary instructions */
        }

        .upload-subtext {
            color: #999;
            margin-bottom: 30px;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(42, 82, 152, 0.3);
        }

        .options-section {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .option-group label {
            font-weight: 600;
            color: #333;
        }

        .option-group select,
        .option-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
        }

        .toggle-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .toggle-button {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #6c757d;
            border: 2px solid #dee2e6;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .toggle-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .toggle-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            border-color: #adb5bd;
        }

        .toggle-button:hover::before {
            left: 100%;
        }

        .toggle-button.active {
            background: linear-gradient(135deg, #2a5298 0%, #1e3c72 100%);
            color: white;
            border-color: #2a5298;
            box-shadow: 0 6px 20px rgba(42, 82, 152, 0.3);
        }

        .toggle-button.active:hover {
            box-shadow: 0 8px 25px rgba(42, 82, 152, 0.4);
            transform: translateY(-3px);
        }

        .toggle-button.active::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
        }

        .toggle-button.processing {
            animation: pulseProcess 1s ease-in-out infinite;
        }

        @keyframes pulseProcess {
            0% { box-shadow: 0 6px 20px rgba(42, 82, 152, 0.3); }
            50% { box-shadow: 0 6px 25px rgba(255, 107, 53, 0.4); }
            100% { box-shadow: 0 6px 20px rgba(42, 82, 152, 0.3); }
        }

        /* Multi-file tab system */
        .file-tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            overflow-x: auto;
            border-bottom: 2px solid #dee2e6;
            margin-top: 20px;
        }

        .file-tab {
            padding: 12px 20px;
            background: #e9ecef;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            color: #6c757d;
            border-radius: 8px 8px 0 0;
            margin-right: 2px;
        }

        .file-tab:hover {
            background: #dee2e6;
            color: #495057;
        }

        .file-tab.active {
            background: #2a5298;
            color: white;
            box-shadow: 0 2px 8px rgba(42, 82, 152, 0.3);
        }

        .file-tab.processing {
            background: #ff9800;
            color: white;
            animation: pulseTab 1s ease-in-out infinite;
        }

        @keyframes pulseTab {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .tab-content {
            display: none;
            background: white;
            border-radius: 0 0 10px 10px;
            border: 2px solid #dee2e6;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }

        .file-queue {
            display: none;
            margin: 20px 0;
        }

        .file-queue.show {
            display: block;
        }

        .file-item {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .file-item.processed {
            border-color: #28a745;
            background: #d4edda;
        }

        .file-item.processing {
            border-color: #ff9800;
            background: #fff3e0;
        }

        .file-item.error {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .file-info-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-icon-large {
            font-size: 2em;
        }

        .file-details-multi {
            flex-grow: 1;
        }

        .file-details-multi h4 {
            margin: 0 0 5px 0;
            color: #333;
        }

        .file-details-multi p {
            margin: 0;
            color: #666;
            font-size: 0.9em;
        }

        .file-actions-multi {
            display: flex;
            gap: 10px;
        }

        .process-all-section {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .hidden-checkbox {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2a5298, #667eea);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-section {
            margin-top: 40px;
            display: none;
        }

        .results-header {
            background: #e8f5e8;
            padding: 20px;
            border-radius: 10px 10px 0 0;
            border-left: 4px solid #4caf50;
        }

        .results-content {
            background: #f8f9fa;
            color: #333;
            padding: 20px;
            border-radius: 0 0 10px 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 15px;
            line-height: 1.8;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .results-content.plain-mode {
            background: #ffffff;
            border: 1px solid #dee2e6;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            padding: 15px;
        }

        .timestamp {
            background: #e3f2fd;
            color: #1565c0;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 13px;
        }

        .log-error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #c62828;
        }

        .log-security {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #f57c00;
        }

        .log-warning {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #f9a825;
        }

        .log-success {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #2e7d32;
        }

        .log-info {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 6px;
            color: #7b1fa2;
        }

        .log-repeated {
            background: #fce4ec;
            border-left: 4px solid #e91e63;
            padding: 8px 16px;
            margin: 4px 0;
            border-radius: 6px;
            color: #c2185b;
            font-weight: 600;
        }

        .log-normal {
            padding: 8px 16px;
            margin: 4px 0;
            color: #666;
        }

        .log-plain {
            padding: 4px 8px;
            margin: 2px 0;
            color: #333;
            background: white;
            border: none;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .log-plain.highlighted {
            background: #fff3cd !important;
            border-left: 3px solid #ffc107 !important;
            padding-left: 12px !important;
        }

        .summary-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .summary-header {
            font-weight: 600;
            color: #856404;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tags-section {
            margin: 20px 0;
        }

        .tag {
            display: inline-block;
            background: #2a5298;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            margin: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tag:hover {
            background: #1e3c72;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(42, 82, 152, 0.3);
        }

        .tag.active {
            background: #ff6b35;
            box-shadow: 0 0 0 2px #ff6b35, 0 0 10px rgba(255, 107, 53, 0.3);
        }

        .log-entry.highlighted {
            animation: highlightPulse 0.6s ease-in-out;
            box-shadow: 0 0 0 3px #ff6b35, 0 4px 12px rgba(255, 107, 53, 0.2);
            transform: scale(1.02);
        }

        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 0 #ff6b35; }
            50% { box-shadow: 0 0 0 6px rgba(255, 107, 53, 0.4); }
            100% { box-shadow: 0 0 0 3px #ff6b35; }
        }

        .metadata-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .metadata-item {
            text-align: center;
        }

        .metadata-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #2a5298;
        }

        .metadata-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #dc3545;
        }

        .file-preview {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        .file-preview.show {
            display: block;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-icon {
            font-size: 3em;
            color: #4caf50;
        }

        .file-details h3 {
            margin: 0 0 5px 0;
            color: #2e7d32;
            font-size: 1.2em;
        }

        .file-details p {
            margin: 0;
            color: #666;
            font-size: 0.9em;
        }

        .file-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn-small {
            background: #2a5298;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            background: #1e3c72;
            transform: translateY(-1px);
        }

        .btn-remove {
            background: #dc3545;
        }

        .btn-remove:hover {
            background: #c82333;
        }

        .upload-success {
            color: #4caf50;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drag-drop-area.file-selected {
            border-color: #4caf50;
            background: #f1f8e9;
            padding: 30px 20px;
        }

        .drag-drop-area.file-selected .upload-icon {
            color: #4caf50;
        }

        .drag-drop-area.file-selected .upload-text {
            color: #2e7d32;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Real-time notification animations */
        @keyframes slideInRight {
            from {
                transform: translateX(300px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(300px);
                opacity: 0;
            }
        }

        /* Self-monitoring panel styles */
        .self-monitoring-section {
            margin-top: 40px;
            background: linear-gradient(135deg, #fff3e0 0%, #fce4ec 100%);
            border-radius: 15px;
            border: 2px solid #ff6b35;
            overflow: hidden;
        }

        .self-monitoring-section .section-header {
            background: linear-gradient(135deg, #ff6b35 0%, #c44569 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .self-monitoring-section h3 {
            margin: 0;
            font-size: 1.4em;
        }

        .self-monitoring-section .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .self-monitoring-status {
            padding: 20px;
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .self-monitoring-status p {
            margin: 0;
            font-weight: 600;
        }

        .self-monitoring-status span {
            color: #c44569;
            font-weight: 700;
        }

        .self-monitoring-errors {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .self-error-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #ff6b35;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.1);
        }

        .self-error-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .self-error-type {
            font-weight: 700;
            color: #c44569;
        }

        .self-error-time {
            font-size: 0.9em;
            color: #666;
        }

        .self-error-message {
            margin-bottom: 8px;
            color: #333;
        }

        .self-error-context {
            font-size: 0.9em;
            color: #666;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .options-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üêû Debuggle</h1>
            <p>Transform chaotic logs into clear, understandable insights</p>
            <div style="margin-top: 15px;">
                <button class="btn-secondary" onclick="toggleSelfMonitoringPanel()" id="showSelfMonitoring">
                    üîß Developer Tools
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <div class="drag-drop-area" id="dragDropArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Drag & drop your log file(s) here</div>
                    <div class="upload-subtext">Single files auto-analyze ‚Ä¢ Multiple files need manual analysis</div>
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                    <input type="file" id="fileInput" class="file-input" accept=".log,.txt,.out,.err,.json" multiple>
                </div>

                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>

                <div class="file-preview" id="filePreview">
                    <div class="file-info">
                        <div class="file-icon">üìÑ</div>
                        <div class="file-details">
                            <h3 id="fileName">filename.log</h3>
                            <p id="fileSize">File size ‚Ä¢ Ready to analyze</p>
                        </div>
                    </div>
                    <div class="file-actions">
                        <div class="upload-success" id="uploadSuccess" style="display: none;">
                            ‚úÖ File uploaded successfully!
                        </div>
                        <button class="btn-small" onclick="processFile()" id="processBtn">
                            Process File
                        </button>
                        <button class="btn-small btn-remove" onclick="removeFile()" id="removeBtn">
                            Remove
                        </button>
                    </div>
                </div>
            </div>

            <div class="options-section">
                <div class="toggle-group">
                    <input type="checkbox" id="summarize" class="hidden-checkbox" checked>
                    <div class="toggle-button active" onclick="toggleOption('summarize', this)">
                        üß† Generate Smart Analysis
                    </div>
                </div>

                <div class="toggle-group">
                    <input type="checkbox" id="tags" class="hidden-checkbox" checked>
                    <div class="toggle-button active" onclick="toggleOption('tags', this)">
                        üè∑Ô∏è Show Interactive Tags
                    </div>
                </div>

                <div class="toggle-group">
                    <input type="checkbox" id="highlight" class="hidden-checkbox" checked>
                    <div class="toggle-button active" onclick="toggleOption('highlight', this)">
                        ‚ú® Enhanced Formatting
                    </div>
                </div>
            </div>

            <div class="results-section" id="resultsSection">
                <div id="summarySection" class="summary-section" style="display: none;">
                    <div class="summary-header">
                        üß† Smart Analysis
                    </div>
                    <div id="summaryContent"></div>
                </div>

                <div id="tagsSection" class="tags-section" style="display: none;">
                    <strong>Tags:</strong>
                    <div id="tagsContent"></div>
                </div>

                <div class="results-header">
                    <strong>üîç Analyzed Log Output</strong>
                </div>
                <div class="results-content" id="resultsContent"></div>

                <div class="metadata-section" id="metadataSection">
                    <!-- Metadata will be populated here -->
                </div>
            </div>

            <!-- Self-monitoring panel -->
            <div class="self-monitoring-section" id="selfMonitoringSection" style="display: none;">
                <div class="section-header">
                    <h3>üêû Debuggle Self-Monitoring</h3>
                    <div class="controls">
                        <button class="btn-secondary" onclick="toggleSelfMonitoring()" id="selfMonitoringToggle">
                            Enable Monitoring
                        </button>
                        <button class="btn-secondary" onclick="clearSelfMonitoringErrors()">
                            Clear Errors
                        </button>
                        <button class="btn-secondary" onclick="testSelfMonitoring()">
                            Test Error
                        </button>
                        <button class="btn-secondary" onclick="toggleSelfMonitoringPanel()">
                            Hide Panel
                        </button>
                    </div>
                </div>
                <div class="self-monitoring-status" id="selfMonitoringStatus">
                    <p>Status: <span id="monitoringStatusText">Checking...</span></p>
                    <p>Internal Errors: <span id="errorCountText">0</span></p>
                </div>
                <div class="self-monitoring-errors" id="selfMonitoringErrors">
                    <!-- Recent errors will appear here -->
                </div>
            </div>

            <div id="errorMessage" class="error-message" style="display: none;"></div>
        </div>
    </div>

    <!--
    ‚ö° JAVASCRIPT CONTROL SYSTEM - The Brain and Nervous System of Our Dashboard
    ===========================================================================
    
    Everything between <script> tags is JavaScript code - the "electrical system"
    that makes our beautiful dashboard actually work and respond to user actions.
    
    üèÜ HIGH SCHOOL EXPLANATION:
    Think of our web page like a sophisticated smart home or gaming setup:
    
    1. üìã HTML = The house structure (rooms, walls, doors, windows)
    2. üé® CSS = The decoration and design (paint, furniture, lighting)  
    3. ‚ö° JAVASCRIPT = The electrical and smart systems (lights, security, automation)
    
    JavaScript is what turns our static, pretty webpage into an interactive,
    intelligent system that can:
    - Respond to mouse clicks and keyboard input
    - Communicate with servers over the internet
    - Update content in real-time without page refreshes
    - Process files and display results dynamically
    
    We'll use metaphors like electrical systems, control panels, automation,
    and smart home technology to explain how JavaScript creates interactivity.
    -->
    <script>
        /*
        üéõÔ∏è CONTROL PANEL CONNECTIONS - Linking JavaScript to HTML elements
        ==================================================================
        
        These variables are like connecting wires that link our JavaScript "brain"
        to specific parts of our HTML interface. Each getElementById() call is
        like plugging a wire into a specific component on our control panel.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like setting up a home theater system where you need to
        connect the remote control to each device:
        - dragDropArea = connect to the file drop zone
        - progressBar = connect to the loading indicator  
        - resultsSection = connect to the output display
        
        Once connected, our JavaScript can control these elements, change their
        content, hide/show them, or respond when users interact with them.
        */
        
        // üì± USER INTERFACE CONTROLS - connecting to interactive elements
        const dragDropArea = document.getElementById('dragDropArea');      // üéØ File drop zone
        const fileInput = document.getElementById('fileInput');            // üìÅ Hidden file picker
        const progressBar = document.getElementById('progressBar');        // üìä Loading indicator container
        const progressFill = document.getElementById('progressFill');      // üìà Actual progress bar fill
        
        // üì∫ DISPLAY SCREENS - connecting to content display areas
        const resultsSection = document.getElementById('resultsSection');    // üìã Main results container
        const resultsContent = document.getElementById('resultsContent');    // üìÑ Processed log content
        const summarySection = document.getElementById('summarySection');    // üß† AI analysis summary
        const summaryContent = document.getElementById('summaryContent');    // üí≠ Summary text content
        const tagsSection = document.getElementById('tagsSection');          // üè∑Ô∏è Interactive tags area
        const tagsContent = document.getElementById('tagsContent');          // üéØ Tag buttons container
        
        // üìã STATUS AND FEEDBACK DISPLAYS - connecting to user feedback elements
        const metadataSection = document.getElementById('metadataSection');  // üìä File information display
        const errorMessage = document.getElementById('errorMessage');        // ‚ö†Ô∏è Error notification area
        const filePreview = document.getElementById('filePreview');          // üëÅÔ∏è File preview container
        const fileName = document.getElementById('fileName');                // üìÑ Display selected filename
        const fileSize = document.getElementById('fileSize');                // üìè Display file size info
        const uploadSuccess = document.getElementById('uploadSuccess');      // ‚úÖ Success notification
        
        // üéÆ ACTION BUTTONS - connecting to user controls
        const processBtn = document.getElementById('processBtn');            // ‚ö° Process/analyze button
        const removeBtn = document.getElementById('removeBtn');              // üóëÔ∏è Remove file button
        
        /*
        üì° REAL-TIME COMMUNICATION SYSTEM - Live connection to server
        ============================================================
        
        These variables set up our "radio communication" system that lets our
        dashboard talk to the server in real-time, like having a live video call
        or chat connection that stays open for instant updates.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like having a walkie-talkie or Discord voice chat that
        stays connected while you're playing online games:
        - websocket = the open communication channel
        - realtimeErrors = a list of all messages received
        - connectionStatus = whether we're currently "online" or "offline"
        */
        let websocket = null;                    // üìª Real-time communication channel
        let realtimeErrors = [];                 // üìö Collection of all received error messages
        let realtimeConnectionStatus = 'disconnected';  // üö¶ Current connection status
        
        /*
        üóÇÔ∏è DATA MANAGEMENT SYSTEM - Keeping track of files and user choices
        ===================================================================
        
        These variables are like having different filing cabinets and clipboards
        to keep track of what the user is doing and what files they're working with.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like managing homework assignments or organizing photos:
        - selectedFile = the current assignment you're working on
        - selectedFiles = all the assignments you need to complete
        - fileQueue = the order you'll work on them
        - lastProcessedData = keeping the results so you can reference them later
        */
        let selectedFile = null;                 // üìÑ Currently active file
        let selectedFiles = [];                  // üìÅ All uploaded files  
        let currentFileIndex = 0;                // üî¢ Which file we're currently viewing
        let lastProcessedData = null;            // üíæ Store results for live filtering
        let fileQueue = [];                      // üìã Queue for multiple files
        let activeTab = null;                    // üóÇÔ∏è Currently selected tab/view
        
        /*
        üì° REAL-TIME MONITORING SETUP - Establishing live communication with server
        ===========================================================================
        
        This function sets up our "radio tower" that maintains a constant connection
        to the Debuggle server, allowing us to receive error notifications instantly
        as they happen, like having a live news feed or stock ticker.
        
        üèÜ HIGH SCHOOL EXPLANATION:
        Think of this like setting up a live stream or video call:
        1. Figure out the right "phone number" (WebSocket URL)
        2. Place the call (create WebSocket connection)
        3. Set up what to do when the call connects (onopen)
        4. Set up what to do when messages arrive (onmessage)
        5. Handle any connection problems (error handling)
        
        Once this is working, our dashboard can show live updates without the
        user having to refresh the page, like notifications on your phone.
        */
        function initRealtimeMonitoring() {
            // üåê SMART URL BUILDING - automatically use secure connection if needed
            // Like automatically switching between regular phone calls and encrypted calls
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/errors`;
            
            // üìû ESTABLISH CONNECTION - "dial the server" to start live communication
            // Like placing a video call or starting a live stream
            websocket = new WebSocket(wsUrl);
            
            /*
            ‚úÖ CONNECTION SUCCESS HANDLER - what to do when we get connected
            
            This is like the "call connected" notification - we update our status
            display to show users that live monitoring is now active.
            */
            websocket.onopen = function(event) {
                console.log('Real-time error monitoring connected');   // üìù Developer log message
                realtimeConnectionStatus = 'connected';               // üö¶ Update our status tracker
                updateConnectionStatus();                             // üîÑ Update the UI display
            };
            
            /*
            üì® MESSAGE HANDLER - what to do when new error data arrives
            
            This is like having a notification handler on your phone - when a new
            message arrives, we need to process it and update our display.
            */
            websocket.onmessage = function(event) {
                try {
                    // üì¶ UNPACK THE MESSAGE - convert from text to usable data
                    // Like opening an envelope and reading the contents
                    const data = JSON.parse(event.data);
                    handleRealtimeMessage(data);                      // üéØ Process the error data
                } catch (error) {
                    // üö® HANDLE CORRUPTED MESSAGES - deal with garbled data gracefully
                    console.error('Error parsing WebSocket message:', error);
                }
            };
            
            websocket.onclose = function(event) {
                console.log('Real-time error monitoring disconnected');
                realtimeConnectionStatus = 'disconnected';
                updateConnectionStatus();
                
                // Attempt to reconnect after 5 seconds
                setTimeout(() => {
                    if (realtimeConnectionStatus === 'disconnected') {
                        initRealtimeMonitoring();
                    }
                }, 5000);
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                realtimeConnectionStatus = 'error';
                updateConnectionStatus();
            };
        }
        
        function handleRealtimeMessage(data) {
            switch (data.type) {
                case 'welcome':
                    console.log('Real-time monitoring:', data.message);
                    if (data.recent_errors) {
                        realtimeErrors = data.recent_errors;
                        updateRealtimeErrorsDisplay();
                    }
                    break;
                    
                case 'error':
                    // New error reported
                    const errorEvent = {
                        id: data.id,
                        timestamp: data.timestamp,
                        error_type: data.error_type,
                        message: data.message,
                        source: data.source,
                        severity: data.severity,
                        metadata: data.metadata
                    };
                    realtimeErrors.unshift(errorEvent);
                    
                    // Keep only last 50 errors
                    if (realtimeErrors.length > 50) {
                        realtimeErrors = realtimeErrors.slice(0, 50);
                    }
                    
                    updateRealtimeErrorsDisplay();
                    showRealtimeErrorNotification(errorEvent);
                    break;
                    
                case 'self_monitoring_error':
                    // Debuggle's own internal error
                    console.warn('üêû Debuggle Internal Error:', data.error);
                    showSelfMonitoringError(data.error);
                    break;
                    
                case 'stats_update':
                    console.log('Error stats updated:', data.error_stats);
                    break;
                    
                case 'monitoring_status':
                    console.log('Monitoring status:', data.message);
                    break;
                    
                case 'pong':
                    // Keep-alive response
                    break;
                    
                default:
                    console.log('Unknown realtime message:', data);
            }
        }
        
        function updateConnectionStatus() {
            // You could add a status indicator to the UI here
            const statusColors = {
                'connected': '#4caf50',
                'disconnected': '#f44336',
                'error': '#ff9800'
            };
            
            // Update header background color slightly to indicate connection status
            document.querySelector('.header').style.borderBottom = 
                `3px solid ${statusColors[realtimeConnectionStatus]}`;
        }
        
        function updateRealtimeErrorsDisplay() {
            // This could be enhanced to show recent errors in a sidebar or notification area
            console.log(`${realtimeErrors.length} real-time errors tracked`);
        }
        
        function showRealtimeErrorNotification(errorEvent) {
            // Create a temporary notification for new errors
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ff6b35;
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
                z-index: 1000;
                max-width: 300px;
                animation: slideInRight 0.3s ease-out;
            `;
            
            notification.innerHTML = `
                <strong>üö® ${errorEvent.error_type}</strong><br>
                <small>${errorEvent.message.substring(0, 100)}${errorEvent.message.length > 100 ? '...' : ''}</small>
            `;
            
            document.body.appendChild(notification);
            
            // Remove notification after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }
        
        function showSelfMonitoringError(error) {
            // Create a special notification for Debuggle's own errors
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
                color: white;
                padding: 20px;
                border-radius: 15px;
                box-shadow: 0 8px 24px rgba(255, 71, 87, 0.4);
                z-index: 1001;
                max-width: 400px;
                border-left: 5px solid #fff;
                animation: slideInRight 0.3s ease-out;
            `;
            
            const timestamp = new Date(error.timestamp).toLocaleTimeString();
            const contextInfo = error.context ? ` (${error.context})` : '';
            const endpointInfo = error.endpoint ? ` at ${error.endpoint}` : '';
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 1.5em; margin-right: 10px;">üêû</span>
                    <strong>Debuggle Internal Error</strong>
                </div>
                <div style="margin-bottom: 8px;">
                    <strong>${error.error_type}</strong>${contextInfo}${endpointInfo}
                </div>
                <div style="font-size: 0.9em; margin-bottom: 8px; opacity: 0.9;">
                    ${error.message.substring(0, 150)}${error.message.length > 150 ? '...' : ''}
                </div>
                <div style="font-size: 0.8em; opacity: 0.7;">
                    ${timestamp} ‚Ä¢ Source: ${error.source}
                </div>
                ${error.traceback ? `
                    <details style="margin-top: 10px; font-size: 0.8em;">
                        <summary style="cursor: pointer; opacity: 0.8;">View Traceback</summary>
                        <pre style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 0.7em; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${error.traceback}</pre>
                    </details>
                ` : ''}
            `;
            
            document.body.appendChild(notification);
            
            // Add click to dismiss
            notification.style.cursor = 'pointer';
            notification.onclick = () => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            };
            
            // Auto-remove after 10 seconds (longer for self-monitoring errors)
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 10000);
        }
        
        function sendWebSocketMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(message));
            }
        }
        
        // Self-monitoring functionality
        let selfMonitoringEnabled = false;
        
        function toggleSelfMonitoringPanel() {
            const panel = document.getElementById('selfMonitoringSection');
            const button = document.getElementById('showSelfMonitoring');
            
            if (panel.style.display === 'none' || !panel.style.display) {
                panel.style.display = 'block';
                button.textContent = 'üîß Hide Developer Tools';
                // Load initial status
                refreshSelfMonitoringStatus();
            } else {
                panel.style.display = 'none';
                button.textContent = 'üîß Developer Tools';
            }
        }
        
        async function toggleSelfMonitoring() {
            const newState = !selfMonitoringEnabled;
            
            try {
                const response = await fetch('/api/v1/self-monitor/toggle', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ enabled: newState })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    selfMonitoringEnabled = result.enabled;
                    updateSelfMonitoringToggleButton();
                    refreshSelfMonitoringStatus();
                } else {
                    console.error('Failed to toggle self-monitoring');
                }
            } catch (error) {
                console.error('Error toggling self-monitoring:', error);
            }
        }
        
        function updateSelfMonitoringToggleButton() {
            const button = document.getElementById('selfMonitoringToggle');
            button.textContent = selfMonitoringEnabled ? 'Disable Monitoring' : 'Enable Monitoring';
            button.style.background = selfMonitoringEnabled ? 
                'rgba(244, 67, 54, 0.2)' : 'rgba(76, 175, 80, 0.2)';
        }
        
        async function refreshSelfMonitoringStatus() {
            try {
                const response = await fetch('/api/v1/self-monitor/status');
                if (response.ok) {
                    const data = await response.json();
                    
                    document.getElementById('monitoringStatusText').textContent = 
                        data.monitoring_enabled ? 'Active' : 'Inactive';
                    document.getElementById('errorCountText').textContent = 
                        data.total_errors;
                    
                    selfMonitoringEnabled = data.monitoring_enabled;
                    updateSelfMonitoringToggleButton();
                    
                    // Display recent errors
                    displaySelfMonitoringErrors(data.recent_errors);
                }
            } catch (error) {
                console.error('Error refreshing self-monitoring status:', error);
            }
        }
        
        function displaySelfMonitoringErrors(errors) {
            const container = document.getElementById('selfMonitoringErrors');
            
            if (!errors || errors.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No recent errors</p>';
                return;
            }
            
            container.innerHTML = errors.map(error => {
                const timestamp = new Date(error.timestamp).toLocaleString();
                const contextInfo = error.context ? ` (${error.context})` : '';
                const endpointInfo = error.endpoint ? ` at ${error.endpoint}` : '';
                
                return `
                    <div class="self-error-item">
                        <div class="self-error-header">
                            <span class="self-error-type">${error.error_type}${contextInfo}${endpointInfo}</span>
                            <span class="self-error-time">${timestamp}</span>
                        </div>
                        <div class="self-error-message">${error.message}</div>
                        ${error.source ? `<div class="self-error-context">Source: ${error.source}</div>` : ''}
                        ${error.traceback ? `
                            <details style="margin-top: 10px;">
                                <summary style="cursor: pointer; color: #c44569;">View Traceback</summary>
                                <pre style="margin-top: 8px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 0.8em; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${error.traceback}</pre>
                            </details>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        async function clearSelfMonitoringErrors() {
            try {
                const response = await fetch('/api/v1/self-monitor/clear', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    refreshSelfMonitoringStatus();
                } else {
                    console.error('Failed to clear self-monitoring errors');
                }
            } catch (error) {
                console.error('Error clearing self-monitoring errors:', error);
            }
        }
        
        async function testSelfMonitoring() {
            try {
                const response = await fetch('/api/v1/self-monitor/test-error', {
                    method: 'POST'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    // Refresh status to show the new test error
                    setTimeout(() => refreshSelfMonitoringStatus(), 500);
                } else {
                    console.error('Failed to generate test error');
                }
            } catch (error) {
                console.error('Error generating test error:', error);
            }
        }
        
        // Start real-time monitoring when page loads
        window.addEventListener('load', function() {
            initRealtimeMonitoring();
            
            // Send periodic pings to keep connection alive
            setInterval(() => {
                sendWebSocketMessage({ type: 'ping' });
            }, 30000);
        });

        // Drag and drop functionality
        dragDropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dragDropArea.classList.add('drag-over');
        });

        dragDropArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragDropArea.classList.remove('drag-over');
        });

        dragDropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dragDropArea.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFiles(Array.from(files));
            }
        });

        dragDropArea.addEventListener('click', (e) => {
            // Only trigger file input if not clicking on the button
            if (!e.target.closest('button')) {
                fileInput.click();
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
                // Clear the input value to allow selecting the same file again
                e.target.value = '';
            }
        });

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant host who greets customers at the door
        and decides where to seat them. When someone brings files to our web page,
        this function looks at how many files they brought and decides what to do:
        - If they brought 1 file: "Right this way to your table, we'll start cooking immediately!"
        - If they brought multiple files: "Please take a seat, here's the menu to decide what you want"
        
        Just like a good host clears the previous table before seating new customers,
        this function clears any old error messages or results before handling new files.
        */
        function handleFiles(files) {
            // üßπ CLEAR THE DINING ROOM - Reset the web page interface
            // Like clearing tables and wiping down surfaces before new customers arrive
            hideError();
            hideResults();
            
            if (files.length === 1) {
                // üçΩÔ∏è SINGLE CUSTOMER SERVICE - One file gets immediate attention
                // Like seating a solo diner at a table and immediately bringing the menu
                selectedFile = files[0];
                showFilePreview(files[0]);
                
                // ‚è∞ BRIEF PAUSE FOR PRESENTATION - Let the customer see the menu first
                // Like giving someone a moment to look at their table setting before taking their order
                setTimeout(() => {
                    processFile();
                }, 500);
            } else {
                // üë• GROUP PARTY HANDLING - Multiple files need coordination  
                // Like seating a large party and letting them browse the menu together
                selectedFiles = files;
                showMultipleFilePreview(files);
            }
        }

        function handleFile(file) {
            // Backward compatibility - convert single file to array
            handleFiles([file]);
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a waiter showing a single customer to their table
        and immediately preparing their dining experience. When someone selects
        one file, we want to make it feel personal and immediate - like getting
        VIP treatment at a restaurant where they know your name and preferences.
        
        The function updates the visual appearance to show "someone is seated here"
        and displays information about their order (file name and size), then
        smoothly guides their attention to the right spot on the page.
        */
        function showFilePreview(file) {
            // üí∫ TABLE RESERVATION - Mark this table as occupied
            // Like putting down a "Reserved" sign and adjusting the table setting
            dragDropArea.classList.add('file-selected');
            
            // üìã ORDER TAKING - Display what the customer brought
            // Like writing down their name and special requests on the order pad
            fileName.textContent = file.name;
            fileSize.textContent = `${formatFileSize(file.size)} ‚Ä¢ ${getFileIcon(file.name)} Auto-analyzing...`;
            
            // üé≠ STAGE LIGHTING - Highlight the dining area
            // Like turning on a spotlight over their table to show they're being served
            filePreview.classList.add('show');
            
            // üéõÔ∏è SERVICE SETUP - Prepare the service experience
            // Like clearing unnecessary items from the table since this is express service
            uploadSuccess.style.display = 'none';
            processBtn.style.display = 'none';
            processBtn.textContent = 'Process File';
            processBtn.disabled = false;
            
            // üéØ GUIDED ATTENTION - Smoothly direct their focus
            // Like a gentle "right this way" gesture guiding them to look at their table
            filePreview.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant manager handling a large party reservation.
        When a group of people (multiple files) arrives, you can't just seat them
        anywhere - you need to organize them, give each person a number, and create
        a system to track their orders and preferences.
        
        Think of it like managing a busy restaurant during dinner rush:
        - Each person gets a unique table number (ID)
        - Everyone starts with "waiting to order" status (pending)
        - You create a organized waiting list and seating chart
        - Then guide the group's attention to where they should look
        */
        function showMultipleFilePreview(files) {
            // üè¢ BANQUET HALL SETUP - Prepare for group service
            // Like setting up a large dining area and clearing previous events
            dragDropArea.classList.add('file-selected');
            hideResults();
            
            // üìã GUEST LIST CREATION - Organize each file with tracking information
            // Like creating a reservation list where each guest gets a table number and status
            fileQueue = files.map((file, index) => ({
                id: `file_${Date.now()}_${index}`,     // Unique table number (like "Table 5A")
                file: file,                            // The guest's information
                status: 'pending',                     // Current service status (pending, processing, completed, error)
                data: null,                           // Their completed order (results)
                error: null                           // Any service problems
            }));
            
            // üé≠ STAGE TRANSITION - Switch from single-person to group layout
            // Like converting a small intimate table setup to a large banquet arrangement
            filePreview.classList.remove('show');
            
            // üèóÔ∏è BANQUET SETUP - Build the group service interface
            // Like arranging tables, place cards, and service stations for the event
            createFileQueueUI();
            
            // üéØ GROUP GUIDANCE - Direct the party's attention to their area
            // Like a "right this way, your banquet hall is ready" gesture
            document.getElementById('fileQueue').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant manager designing the layout for a large
        banquet event. When you have many guests (files) to serve, you need to create
        an organized system with clear sections:
        - A welcome area with event information (header)
        - Service options like "serve everyone" or "clear the hall" (action buttons)
        - Individual table assignments for each guest (file list)
        - Areas for displaying each guest's meal results (tabs and content areas)
        
        It's like setting up a wedding reception with proper signage, service stations,
        and areas for each part of the event to run smoothly.
        */
        function createFileQueueUI() {
            // üìä GUEST COUNT - Figure out how many people are waiting for service
            // Like counting how many people still need to place their orders
            const pendingCount = fileQueue.filter(f => f.status === 'pending').length;
            
            // üèóÔ∏è BANQUET HALL BLUEPRINT - Design the complete event layout
            // Like creating a floor plan with all the necessary areas and stations
            const fileQueueHtml = `
                <div class="file-queue show" id="fileQueue">
                    <div class="queue-header">
                        <h3>üìÅ Multiple Files Ready for Analysis</h3>
                        <p>Review your files below and analyze them individually or all at once.</p>
                    </div>
                    <div class="queue-actions">
                        <button class="btn-primary" onclick="processAllFiles()" id="processAllBtn">
                            üöÄ Process All ${pendingCount} Files
                        </button>
                        <button class="btn-secondary" onclick="removeFile()">
                            üóëÔ∏è Clear All Files
                        </button>
                    </div>
                    <div class="file-list" id="fileList">
                        ${fileQueue.map(item => createFileItemHTML(item)).join('')}
                    </div>
                    <div class="file-tabs" id="fileTabs" style="display: none;"></div>
                    <div class="tab-contents" id="tabContents"></div>
                </div>
            `;
            
            // üè† VENUE PREPARATION - Set up the banquet hall in the right location
            // Like finding the right room and clearing out any previous event setup
            const uploadSection = document.querySelector('.upload-section');
            const existingQueue = document.getElementById('fileQueue');
            if (existingQueue) {
                existingQueue.remove();  // Clear any previous banquet setup
            }
            uploadSection.insertAdjacentHTML('afterend', fileQueueHtml);
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like creating individual place cards or table settings
        for each guest at a banquet. For every person (file) at the event, you
        create a personalized card that shows:
        - Their name and details (file name and size)
        - Their current service status (waiting, being served, finished, or had problems)
        - Available actions (like "take order" or "view bill")
        
        Think of it like those electronic menus at modern restaurants that show
        your order status in real-time, with different icons and buttons depending
        on whether your food is being prepared, ready, or needs attention.
        */
        function createFileItemHTML(item) {
            // üé≠ STATUS THEATER - Visual symbols for each service state
            // Like traffic lights or status boards that instantly communicate what's happening
            const statusIcons = {
                pending: '‚è≥',      // Waiting in line (like a "Please Wait" sign)
                processing: 'üîÑ',   // Being served (like a spinning "Preparing Order" indicator)
                completed: '‚úÖ',    // Successfully served (like a "Ready!" notification)
                error: '‚ùå'         // Service problem (like a "Need Help" alert)
            };
            
            // üè∑Ô∏è NAME TAG CREATION - Format the status text professionally
            // Like printing name tags that say "Hello, my status is: Processing"
            const statusClass = item.status;
            const statusText = item.status.charAt(0).toUpperCase() + item.status.slice(1);
            
            // üÉè PLACE CARD DESIGN - Create the complete table setting
            // Like designing a fancy place card with the guest's info and service options
            return `
                <div class="file-item ${statusClass}" id="${item.id}">
                    <div class="file-info-left">
                        <div class="file-icon-large">${getFileIcon(item.file.name)}</div>
                        <div class="file-details-multi">
                            <h4>${item.file.name}</h4>
                            <p>${formatFileSize(item.file.size)} ‚Ä¢ ${statusIcons[item.status]} ${statusText}</p>
                        </div>
                    </div>
                    <div class="file-actions-multi">
                        ${item.status === 'pending' ? `<button class="btn-small" onclick="processSingleFileFromQueue('${item.id}')">Process</button>` : ''}
                        ${item.status === 'completed' ? `<button class="btn-small" onclick="viewFileResults('${item.id}')">View Results</button>` : ''}
                        <button class="btn-small btn-remove" onclick="removeFileFromQueue('${item.id}')">Remove</button>
                    </div>
                </div>
            `;
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant manager deciding how to handle an order.
        When someone clicks "Process" they look at the situation and decide:
        - If there's a group of people (multiple files): "Let's handle this as a banquet order"
        - If there's just one person (single file): "This is a simple individual order"
        
        It's like a smart traffic controller that looks at the situation and directs
        traffic to the right processing lane - group service or individual service.
        */
        function processFile() {
            // üö¶ TRAFFIC CONTROL - Decide which processing lane to use
            // Like a restaurant host deciding between banquet service or individual table service
            if (selectedFiles.length > 0) {
                // üè¢ GROUP BANQUET SERVICE - Handle multiple files together
                // Like coordinating a large event with many guests
                processMultipleFiles();
            } else if (selectedFile) {
                // üçΩÔ∏è INDIVIDUAL TABLE SERVICE - Handle single file with personal attention
                // Like serving a single customer at their own table
                processSingleFile(selectedFile);
            }
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a dedicated waiter taking care of a single customer's
        complete dining experience. When someone orders, the waiter:
        1. Updates the customer that their order is being prepared (show progress)
        2. Writes down all their preferences on the order slip (create form data)
        3. Takes the order to the kitchen (send to server)
        4. Waits for the kitchen to prepare the meal (handle response)
        5. Brings the finished meal to the customer (display results)
        6. Handles any problems that come up (error handling)
        
        It's like having a personal concierge who takes care of everything from
        start to finish for one special customer.
        */
        function processSingleFile(file) {
            // üì± ORDER STATUS UPDATE - Let the customer know their order is being prepared
            // Like updating a digital order board to show "Now Preparing Your Order"
            showProgress();
            
            // üìã ORDER SLIP PREPARATION - Write down all the customer's preferences
            // Like a waiter carefully noting "extra hot sauce, no onions, gluten-free"
            const formData = new FormData();
            formData.append('file', file);                    // The main dish (the file to analyze)
            formData.append('language', 'auto');              // Let the kitchen decide the cooking style
            formData.append('highlight', document.getElementById('highlight').checked);  // "Make it colorful"
            formData.append('summarize', document.getElementById('summarize').checked);  // "Give me the highlights"
            formData.append('tags', document.getElementById('tags').checked);            // "Label the ingredients"
            formData.append('max_lines', '1000');             // "Don't make it too big" (portion control)

            // üöö ORDER DELIVERY TO KITCHEN - Send the order slip to the cooking staff
            // Like a waiter taking the order ticket to the kitchen and waiting for the meal
            fetch('/api/v1/upload-log', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                // üçΩÔ∏è KITCHEN QUALITY CHECK - Make sure the order was prepared correctly
                // Like checking if the kitchen successfully made the dish or had problems
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                // üíæ MEAL MEMORY - Remember this customer's order for future reference
                // Like keeping a record of what they ordered in case they want the same thing again
                lastProcessedData = data;
                
                // üéâ SUCCESS CELEBRATION - Show the customer everything went perfectly
                // Like putting up a "Order Complete!" sign and bringing out the beautifully plated meal
                uploadSuccess.style.display = 'flex';
                
                // üì± STATUS UPDATE - Update the order board with success message
                // Like changing the display from "Preparing..." to "Ready to Enjoy!"
                fileSize.textContent = `${formatFileSize(file.size)} ‚Ä¢ ${getFileIcon(file.name)} Processed successfully!`;
                
                // üçΩÔ∏è MEAL PRESENTATION - Bring the finished dish to the customer
                // Like a waiter presenting the beautifully prepared meal with a flourish
                displayResults(data);
            })
            .catch(error => {
                // üö® KITCHEN EMERGENCY - Handle any problems that occurred
                // Like when the kitchen burns the food or runs out of ingredients
                console.error('Error:', error);
                showError(error.detail?.error || 'An error occurred while analyzing the file.');
                
                // üì± APOLOGY UPDATE - Let the customer know there was a problem
                // Like updating the order board to "Sorry, there was an issue with your order"
                fileSize.textContent = `${formatFileSize(file.size)} ‚Ä¢ ${getFileIcon(file.name)} Analysis failed`;
            })
            .finally(() => {
                // üßπ CLEANUP SERVICE - Always tidy up, whether successful or not
                // Like clearing the "Preparing Order" indicator regardless of outcome
                hideProgress();
            });
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a banquet manager coordinating a large event where
        multiple dishes need to be prepared for many guests. Unlike individual
        table service, this requires:
        - Checking that there are actually guests to serve (file count check)
        - Setting up the kitchen for mass production (processing state)
        - Coordinating the service team (disable controls during service)
        - Starting the assembly line process (begin sequential processing)
        
        Think of it like managing a wedding reception where you need to serve
        200 guests - you can't do it one-by-one, you need a coordinated system.
        */
        function processMultipleFiles() {
            // üîç GUEST COUNT VERIFICATION - Make sure there are actually people to serve
            // Like double-checking the guest list before starting a banquet
            if (selectedFiles.length === 0) return;
            
            // üè≠ MASS PRODUCTION MODE - Set up for large-scale service
            // Like switching the kitchen from "single order" to "banquet production" mode
            processBtn.textContent = 'Analyzing...';          // Update the service indicator
            processBtn.disabled = true;                       // Prevent interruptions during service
            showProgress();                                   // Show the "Event In Progress" sign
            
            // üìã STARTING POSITION - Begin with the first guest
            // Like starting the banquet service with table #1
            currentFileIndex = 0;
            const allResults = [];
            
            // Process files sequentially
            processNextFile(allResults);
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a banquet coordinator managing a multi-course meal
        service. When serving many guests (files), you can't serve everyone at once -
        you need to serve them one by one in order, keeping track of progress:
        - Check if there are more guests to serve
        - If everyone's been served, present the final banquet results
        - If more guests remain, prepare the next course
        
        Think of it like a wedding reception where the coordinator ensures
        each table gets served in sequence, then announces when dinner is complete.
        */
        function processNextFile(allResults) {
            // üìä GUEST COUNT CHECK - See if we've served everyone at the banquet
            // Like checking the guest list to see if any tables are still waiting
            if (currentFileIndex >= selectedFiles.length) {
                // üéâ BANQUET COMPLETION - All guests have been served!
                // Like announcing "Ladies and gentlemen, dinner is served!" at the end
                displayMultipleResults(allResults);
                
                // üé≠ SUCCESS CELEBRATION - Show the event was successful
                // Like putting up "Event Complete" banners and thanking guests
                uploadSuccess.style.display = 'flex';
                processBtn.textContent = 'Reprocess All';  // Change button to "Plan Another Event"
                processBtn.disabled = false;               // Re-enable the event planning button
                hideProgress();                           // Remove the "Service in Progress" sign
                return;
            }
            
            const file = selectedFiles[currentFileIndex];
                fileName.textContent = `Analyzing: ${file.name} (${currentFileIndex + 1}/${selectedFiles.length})`;            // Create form data
            const formData = new FormData();
            formData.append('file', file);
            formData.append('language', 'auto');
            formData.append('highlight', document.getElementById('highlight').checked);
            formData.append('summarize', document.getElementById('summarize').checked);
            formData.append('tags', document.getElementById('tags').checked);
            formData.append('max_lines', '1000');

            // Process current file
            fetch('/api/v1/upload-log', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                // Add file info to results
                data.filename = file.name;
                allResults.push(data);
                
                // Process next file
                currentFileIndex++;
                processNextFile(allResults);
            })
            .catch(error => {
                console.error('Error processing', file.name, ':', error);
                
                // Add error result
                allResults.push({
                    filename: file.name,
                    error: error.detail?.error || 'Processing failed',
                    cleaned_log: '',
                    summary: '',
                    tags: [],
                    metadata: { filename: file.name, file_size: file.size }
                });
                
                // Process next file
                currentFileIndex++;
                processNextFile(allResults);
            });
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant manager doing a complete "table reset"
        after customers leave. When someone wants to start fresh, this function:
        - Clears all customer records (files and queues)
        - Resets all table settings (UI elements)
        - Cleans up any leftover dishes (results and errors)
        - Prepares for the next customers (reset file input)
        
        It's like that moment between restaurant customers when staff quickly
        clear everything and set up fresh place settings for the next party.
        */
        function removeFile() {
            // üóÇÔ∏è CLEAR CUSTOMER RECORDS - Remove all current reservations
            // Like tearing up all the order slips and reservation cards
            selectedFile = null;        // Clear single customer
            selectedFiles = [];         // Clear group reservation
            currentFileIndex = 0;       // Reset service counter to start
            
            // üßπ TABLE RESET - Clean and prepare all surfaces
            // Like clearing dishes, wiping tables, and folding napkins fresh
            dragDropArea.classList.remove('file-selected');  // Remove "occupied" sign
            filePreview.classList.remove('show');            // Hide customer information
            hideResults();                                   // Clear previous meal displays
            hideError();                                     // Remove any problem notices
            
            // üìã FRESH START PREPARATION - Ready for new customers
            // Like putting out a fresh guest book for new visitors to sign
            fileInput.value = '';
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a banquet coordinator presenting the final feast
        after serving many guests (multiple files). Instead of showing each guest's
        meal separately, this function creates one grand buffet display that
        combines everyone's results into a unified presentation:
        - Saves the complete banquet record for later reference
        - Opens the grand dining hall for the presentation
        - Combines all individual meals into one magnificent spread
        - Counts successes and problems for the final report
        
        Think of it like a wedding reception where individual table meals
        get combined into a beautiful buffet presentation for everyone to see.
        */
        function displayMultipleResults(allResults) {
            // üíæ BANQUET MEMORY - Save the complete event details for future reference
            // Like keeping a photo album of the entire wedding reception
            lastProcessedData = { 
                type: 'multiple', 
                results: allResults 
            };
            
            // üé≠ GRAND REVEAL - Open the curtains to show the magnificent banquet hall
            // Like revealing the beautifully decorated reception hall to the guests
            resultsSection.style.display = 'block';
            
            // üçΩÔ∏è BUFFET PREPARATION - Combine all individual meals into one grand display
            // Like arranging all the dishes from different tables into one spectacular buffet
            let combinedLog = '';         // The grand buffet table (empty at start)
            let allTags = new Set();      // Collection of all ingredient labels
            let successCount = 0;         // Count of successfully served dishes
            let errorCount = 0;           // Count of dishes that had problems
            
            // üë®‚Äçüç≥ MEAL COMBINATION - Go through each guest's meal and add it to the buffet
            // Like a head chef combining all the individual table orders into one presentation
            allResults.forEach((result, index) => {
                if (result.error) {
                    // üö® PROBLEM DISH - Note which meals had issues
                    // Like marking "unavailable" on buffet items that couldn't be prepared
                    combinedLog += `\nüìÅ File: ${result.filename}\n‚ùå Error: ${result.error}\n\n`;
                    errorCount++;
                } else {
                    // üéâ SUCCESS DISH - Add beautifully prepared meals to the buffet
                    // Like placing each successful dish on the buffet with proper labels
                    combinedLog += `\nüìÅ File: ${result.filename}\n${result.cleaned_log}\n\n`;
                    if (result.tags) {
                        result.tags.forEach(tag => allTags.add(tag));  // Collect all ingredient labels
                    }
                    successCount++;
                }
            });
            
            // Apply live filtering based on current toggle states
            const showSummary = document.getElementById('summarize').checked;
            const showTags = document.getElementById('tags').checked;
            const showFormatting = document.getElementById('highlight').checked;
            
            // Display combined results with conditional formatting
            if (showFormatting) {
                const formattedLog = formatLogOutput(combinedLog);
                resultsContent.innerHTML = formattedLog;
                resultsContent.classList.remove('plain-mode');
            } else {
                const plainLog = formatPlainLogOutput(combinedLog);
                resultsContent.innerHTML = plainLog;
                resultsContent.classList.add('plain-mode');
            }
            
            // Create combined summary
            const combinedSummary = `Processed ${allResults.length} files: ${successCount} successful, ${errorCount} failed. ` +
                (successCount > 0 ? allResults.filter(r => !r.error).map(r => r.summary).filter(s => s).join(' | ') : '');
            
            if (showSummary && combinedSummary) {
                summarySection.style.display = 'block';
                summaryContent.textContent = combinedSummary;
            } else {
                summarySection.style.display = 'none';
            }
            
            // Display combined tags
            if (showTags && allTags.size > 0) {
                tagsSection.style.display = 'block';
                tagsContent.innerHTML = Array.from(allTags).map((tag, index) => 
                    `<span class="tag" onclick="toggleTagHighlight('${escapeHtml(tag)}', this)" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsSection.style.display = 'none';
            }
            
            // Display metadata for multiple files
            const totalSize = allResults.reduce((sum, result) => sum + (result.metadata?.file_size || 0), 0);
            const totalLines = allResults.reduce((sum, result) => sum + (result.metadata?.lines || 0), 0);
            
            metadataSection.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-value">${allResults.length}</div>
                    <div class="metadata-label">Files Processed</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${successCount}</div>
                    <div class="metadata-label">Successful</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${errorCount}</div>
                    <div class="metadata-label">Failed</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${formatFileSize(totalSize)}</div>
                    <div class="metadata-label">Total Size</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${totalLines}</div>
                    <div class="metadata-label">Total Lines</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">Live Filtered</div>
                    <div class="metadata-label">Processing Mode</div>
                </div>
            `;
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a smart restaurant host who can instantly recognize
        what type of "dish" (file) a customer brought just by looking at it.
        Just like how an experienced server knows the difference between a salad
        and a steak by sight, this function looks at the file extension and
        assigns the perfect emoji "garnish" to represent what type it is.
        
        Think of it like having a smart menu system that automatically puts
        the right icon next to each dish - üêç for Python files, üíõ for JavaScript,
        üìã for log files, etc. It makes everything easier to recognize at a glance!
        */
        function getFileIcon(filename) {
            // üîç FILE TYPE DETECTION - Look at the "dish type" identifier
            // Like checking the last part of a recipe name to know what cuisine it is
            const ext = filename.split('.').pop().toLowerCase();
            
            // üé≠ ICON CATALOG - Our collection of visual "garnishes" for each file type
            // Like having the perfect emoji decoration for every type of dish
            const icons = {
                'log': 'üìã',   // Log files = clipboard (record keeping)
                'txt': 'üìÑ',   // Text files = document page
                'err': '‚ùå',   // Error files = X mark (something went wrong)
                'out': 'üì§',   // Output files = outbox (results going out)
                'json': 'üîß',  // Data files = wrench (technical tools)
                'py': 'üêç',    // Python files = snake (Python's mascot)
                'js': 'üíõ',    // JavaScript files = yellow heart (JS color)
                'java': '‚òï',  // Java files = coffee (Java's name origin)
                'xml': 'üìú'    // Markup files = scroll (formatted documents)
            };
            
            // üé® VISUAL GARNISH SELECTION - Pick the perfect icon or use default
            // Like choosing the right garnish, or using a basic document if we don't have anything specific
            return icons[ext] || 'üìÑ';
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        These functions are like the "Order Status" display at a modern restaurant.
        When you order food, you want to know if it's being prepared, so restaurants
        show progress indicators like "Order Received -> Cooking -> Ready".
        
        showProgress() is like turning on the "Your Order is Being Prepared" sign
        hideProgress() is like turning off the sign when service is complete
        */
        function showProgress() {
            // üì± ACTIVATE STATUS DISPLAY - Turn on the "Order in Progress" indicator
            // Like lighting up a progress bar that shows "We're working on your request"
            progressBar.style.display = 'block';  // Make the progress bar visible
            progressFill.style.width = '100%';    // Show full progress animation
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function turns off the progress indicator when work is finished.
        Like switching off the "Preparing Your Order" sign when the meal is ready.
        */
        function hideProgress() {
            // üîå DEACTIVATE STATUS DISPLAY - Turn off the progress indicator
            // Like switching off the "Order in Progress" light when service is complete
            progressBar.style.display = 'none';   // Hide the progress bar completely
            progressFill.style.width = '0%';       // Reset progress to empty for next time
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant server presenting the finished meal
        to the customer with all their requested customizations. When the kitchen
        finishes preparing the order, this function:
        - Opens the curtains to reveal the dining area (show results section)
        - Checks what the customer requested (summary? colorful? tags?)
        - Plates the food according to their preferences (format the data)
        - Presents it beautifully on the table (display in the web page)
        
        It's like having a smart waiter who remembers exactly how you like
        your food presented and automatically adjusts the presentation style.
        */
        function displayResults(data) {
            // üé≠ STAGE REVEAL - Open the curtains to show the dining area
            // Like dramatically revealing a beautifully set table after preparation
            resultsSection.style.display = 'block';
            
            // üìã CUSTOMER PREFERENCE CHECK - Read their customization requests
            // Like checking the order slip to see "extra sauce, no onions, fancy plating"
            const showSummary = document.getElementById('summarize').checked;      // "Give me the highlights"
            const showTags = document.getElementById('tags').checked;             // "Label the ingredients"  
            const showFormatting = document.getElementById('highlight').checked;  // "Make it colorful and fancy"
            
            // üçΩÔ∏è MEAL PRESENTATION - Plate the food according to customer preferences
            // Like choosing between elegant fine dining plating vs. simple casual presentation
            if (showFormatting) {
                // üé® FINE DINING PRESENTATION - Colorful, artistic plating with garnishes
                // Like a fancy restaurant where every dish is a work of art
                const formattedLog = formatLogOutput(data.cleaned_log);
                resultsContent.innerHTML = formattedLog;
                resultsContent.classList.remove('plain-mode');
            } else {
                // ü•™ CASUAL PRESENTATION - Simple, straightforward, no frills
                // Like a deli sandwich - tasty and functional, but not fancy
                const plainLog = formatPlainLogOutput(data.cleaned_log);
                resultsContent.innerHTML = plainLog;
                resultsContent.classList.add('plain-mode');
            }
            
            // üìÑ MEAL SUMMARY - Provide description if customer wants it
            // Like a waiter explaining "Today's special features locally sourced ingredients..."
            if (showSummary && data.summary) {
                summarySection.style.display = 'block';
                summaryContent.textContent = data.summary;
            } else {
                summarySection.style.display = 'none';
            }
            
            // Display tags conditionally
            if (showTags && data.tags && data.tags.length > 0) {
                tagsSection.style.display = 'block';
                tagsContent.innerHTML = data.tags.map((tag, index) => 
                    `<span class="tag" onclick="toggleTagHighlight('${escapeHtml(tag)}', this)" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsSection.style.display = 'none';
            }
            
            // Display metadata
            const metadata = data.metadata;
            metadataSection.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.filename}</div>
                    <div class="metadata-label">Filename</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${formatFileSize(metadata.file_size)}</div>
                    <div class="metadata-label">File Size</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.lines}</div>
                    <div class="metadata-label">Lines</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.language_detected}</div>
                    <div class="metadata-label">Language</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.processing_time_ms}ms</div>
                    <div class="metadata-label">Processing Time</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">Live Filtered</div>
                    <div class="metadata-label">Processing Mode</div>
                </div>
            `;
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a professional food stylist who makes every dish
        look amazing for a cooking show or magazine photo. When you have raw
        text (like plain ingredients), this function transforms it into a
        beautiful, colorful presentation where:
        - Each line gets its own "plate" (HTML div)
        - Different types of messages get different "garnishes" (colors and styles)
        - Timestamps become elegant "table settings" (special formatting)
        - Error messages get "warning labels" (red styling)
        - Success messages get "celebration decorations" (green styling)
        
        It's like taking a simple home-cooked meal and presenting it like
        a five-star restaurant would - same food, but beautiful presentation.
        */
        function formatLogOutput(logText) {
            // üìÑ RECIPE BREAKDOWN - Separate the ingredients into individual portions
            // Like cutting a large dish into individual servings for plating
            const lines = logText.split('\n');
            
            // üé® ARTISTIC PLATING - Style each line like a master chef presenting food
            // Like carefully arranging each component of a meal on the plate
            const formattedLines = lines.map((line, index) => {
                if (!line.trim()) return '';  // Skip empty plates
                
                // üè∑Ô∏è INGREDIENT LABELING - Figure out what category this line belongs to
                // Like a nutritionist adding tags to identify allergens or dietary info
                const lineTags = getLineTagMapping(line);
                const tagDataAttr = lineTags.length > 0 ? `data-tags="${lineTags.join(',')}"` : '';
                
                // üéØ BASE PRESENTATION - Prepare the basic styling foundation
                // Like putting the main food item on a clean plate before decoration
                let formattedLine = escapeHtml(line);
                
                // ‚è∞ ELEGANT TIMESTAMP STYLING - Make time information look sophisticated
                // Like adding a beautiful clock-shaped garnish to show when the dish was prepared
                formattedLine = formattedLine.replace(
                    /(At \d{1,2}:\d{2}:\d{2} (?:AM|PM) on \w{3} \d{1,2})/g, 
                    '<span class="timestamp">$1</span>'
                );
                
                // üö® MESSAGE CATEGORY STYLING - Use visual cues like a smart restaurant
                // Like using different colored plates for different types of dishes
                if (line.startsWith('‚ùå')) {
                    return `<div class="log-error log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('üîí')) {
                    return `<div class="log-security log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('üìÅ') || line.startsWith('üìß')) {
                    return `<div class="log-warning log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('‚úÖ')) {
                    return `<div class="log-success log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('‚ö†Ô∏è')) {
                    return `<div class="log-repeated log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else if (line.startsWith('‚ÑπÔ∏è')) {
                    return `<div class="log-info log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                } else {
                    return `<div class="log-normal log-entry" ${tagDataAttr}>${formattedLine}</div>`;
                }
            });
            
            return formattedLines.join('');
        }

        function formatPlainLogOutput(logText) {
            // Split into lines and format with minimal styling (PLAIN MODE)
            const lines = logText.split('\n');
            const formattedLines = lines.map((line, index) => {
                if (!line.trim()) return '';
                
                // Determine which tags this line relates to (for tag highlighting to still work)
                const lineTags = getLineTagMapping(line);
                const tagDataAttr = lineTags.length > 0 ? `data-tags="${lineTags.join(',')}"` : '';
                
                // Simple escaped HTML - no fancy colors or styling
                let plainLine = escapeHtml(line);
                
                // Just basic line formatting without colors
                return `<div class="log-plain log-entry" ${tagDataAttr}>${plainLine}</div>`;
            });
            
            return formattedLines.join('');
        }

        function getLineTagMapping(line) {
            const tags = [];
            const lowerLine = line.toLowerCase();
            
            // Map line content to common API tags based on content patterns
            if (lowerLine.includes('connection') || lowerLine.includes('connect')) {
                tags.push('Connection Problems');
            }
            if (lowerLine.includes('database') || lowerLine.includes('db')) {
                tags.push('Database');
            }
            if (lowerLine.includes('error') || lowerLine.includes('exception') || lowerLine.includes('failed')) {
                tags.push('Serious Problems');
            }
            if (lowerLine.includes('critical') || lowerLine.includes('fatal')) {
                tags.push('Critical Error');
            }
            if (lowerLine.includes('warning') || lowerLine.includes('warn')) {
                tags.push('Minor Warnings');
            }
            if (lowerLine.includes('timeout') || lowerLine.includes('slow')) {
                tags.push('Slow Response');
            }
            if (lowerLine.includes('password') || lowerLine.includes('login') || lowerLine.includes('auth')) {
                tags.push('Login Issues');
            }
            if (lowerLine.includes('file') || lowerLine.includes('directory')) {
                tags.push('File Problems');
            }
            if (lowerLine.includes('python') && (lowerLine.includes('traceback') || lowerLine.includes('exception'))) {
                tags.push('Python');
            }
            if (lowerLine.includes('stack trace') || lowerLine.includes('traceback')) {
                tags.push('Stack Trace');
            }
            if (lowerLine.includes('attribute') && lowerLine.includes('error')) {
                tags.push('AttributeError');
            }
            if (lowerLine.includes('needs attention') || lowerLine.includes('developer attention')) {
                tags.push('Needs Attention');
                tags.push('Needs Developer Attention');
            }
            if (lowerLine.includes('programming') && lowerLine.includes('bug')) {
                tags.push('Programming Bug');
            }
            
            return tags;
        }

        let activeTagFilter = null;

        function toggleTagHighlight(tagName, tagElement) {
            // Remove existing highlights
            document.querySelectorAll('.log-entry.highlighted').forEach(entry => {
                entry.classList.remove('highlighted');
            });
            
            // Remove active state from all tags
            document.querySelectorAll('.tag.active').forEach(tag => {
                tag.classList.remove('active');
            });
            
            // If clicking the same tag, clear the filter
            if (activeTagFilter === tagName) {
                activeTagFilter = null;
                return;
            }
            
            // Set new active tag
            activeTagFilter = tagName;
            tagElement.classList.add('active');
            
            // Highlight matching log entries
            let firstMatch = null;
            document.querySelectorAll('.log-entry').forEach(entry => {
                const entryTags = entry.getAttribute('data-tags');
                if (entryTags && entryTags.split(',').includes(tagName)) {
                    entry.classList.add('highlighted');
                    // Track first match for scrolling
                    if (!firstMatch) {
                        firstMatch = entry;
                    }
                }
            });
            
            // Scroll first match into view
            if (firstMatch) {
                firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a smart restaurant server who can instantly re-plate
        your meal when you change your preferences. If you already have food but
        decide "actually, I want this spicy" or "can you make it less colorful",
        this function takes your existing meal and re-presents it with your new
        preferences WITHOUT having to cook it all over again.
        
        Think of it like having a magical food stylist who can instantly change
        how your meal looks based on your current mood - same food, new presentation!
        */
        function liveReprocess() {
            // üîç MEAL CHECK - Make sure there's actually food to re-style
            // Like checking if there's a meal on the table before trying to re-plate it
            if (!lastProcessedData) return;
            
            // üé≠ VISUAL FEEDBACK - Show that re-styling is happening
            // Like putting up a small "Adjusting your presentation" sign
            showLiveProcessingIndicator();
            
            // ‚è∞ BRIEF STYLING PAUSE - Give a moment to show the re-styling process
            // Like a brief dramatic pause before revealing the newly styled meal
            setTimeout(() => {
                // üçΩÔ∏è SMART RE-PRESENTATION - Choose the right re-styling method
                // Like knowing whether to re-style a single dish or an entire banquet
                if (lastProcessedData.type === 'multiple') {
                    displayMultipleResults(lastProcessedData.results);  // Re-style the banquet
                } else {
                    displayResults(lastProcessedData);                  // Re-style the single dish
                }
                hideLiveProcessingIndicator();  // Remove the "styling in progress" sign
            }, 200);
        }

        function stripFormatting(text) {
            // Remove any formatting/styling from the text for plain display
            return text.replace(/\033\[[0-9;]*m/g, ''); // Remove ANSI codes if any
        }

        function showLiveProcessingIndicator() {
            // Add a subtle processing overlay
            resultsContent.style.opacity = '0.6';
            resultsContent.style.transition = 'opacity 0.2s ease';
            
            // Update metadata to show live processing
            const lastMetadataItem = metadataSection.querySelector('.metadata-item:last-child');
            if (lastMetadataItem) {
                const valueDiv = lastMetadataItem.querySelector('.metadata-value');
                if (valueDiv) {
                    valueDiv.textContent = 'Live Processing...';
                    valueDiv.style.color = '#ff6b35';
                }
            }
        }

        function hideLiveProcessingIndicator() {
            // Remove processing overlay
            resultsContent.style.opacity = '1';
            
            // Reset metadata styling
            const lastMetadataItem = metadataSection.querySelector('.metadata-item:last-child');
            if (lastMetadataItem) {
                const valueDiv = lastMetadataItem.querySelector('.metadata-value');
                if (valueDiv) {
                    valueDiv.textContent = 'Live Filtered';
                    valueDiv.style.color = '#2a5298';
                }
            }
        }

        function processSingleFileFromQueue(fileId) {
            const fileItem = fileQueue.find(item => item.id === fileId);
            if (!fileItem) return;
            
            // Update status
            fileItem.status = 'processing';
            updateFileItemDisplay(fileItem);
            
            // Create form data
            const formData = new FormData();
            formData.append('file', fileItem.file);
            formData.append('language', 'auto');
            formData.append('highlight', document.getElementById('highlight').checked);
            formData.append('summarize', document.getElementById('summarize').checked);
            formData.append('tags', document.getElementById('tags').checked);
            formData.append('max_lines', '1000');

            fetch('/api/v1/upload-log', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                // Store results
                fileItem.data = data;
                fileItem.status = 'completed';
                updateFileItemDisplay(fileItem);
                
                // Create tab for this file
                createFileTab(fileItem);
            })
            .catch(error => {
                console.error('Error processing', fileItem.file.name, ':', error);
                fileItem.error = error.detail?.error || 'Processing failed';
                fileItem.status = 'error';
                updateFileItemDisplay(fileItem);
            });
        }

        function processAllFiles() {
            const pendingFiles = fileQueue.filter(item => item.status === 'pending');
            const processAllBtn = document.getElementById('processAllBtn');
            
            if (pendingFiles.length === 0) return;
            
            processAllBtn.textContent = `Processing ${pendingFiles.length} files...`;
            processAllBtn.disabled = true;
            
            // Process files sequentially
            let currentIndex = 0;
            
            function processNext() {
                if (currentIndex >= pendingFiles.length) {
                    processAllBtn.textContent = 'All Files Processed!';
                    setTimeout(() => {
                        processAllBtn.textContent = `üöÄ Process All ${fileQueue.filter(f => f.status === 'pending').length} Files`;
                        processAllBtn.disabled = false;
                    }, 2000);
                    return;
                }
                
                const fileItem = pendingFiles[currentIndex];
                processSingleFileFromQueue(fileItem.id);
                
                // Wait a bit then process next
                setTimeout(() => {
                    currentIndex++;
                    processNext();
                }, 1000);
            }
            
            processNext();
        }

        function updateFileItemDisplay(fileItem) {
            const element = document.getElementById(fileItem.id);
            if (!element) return;
            
            element.className = `file-item ${fileItem.status}`;
            element.innerHTML = createFileItemHTML(fileItem).replace(/^<div[^>]*>|<\/div>$/g, '');
        }

        function removeFileFromQueue(fileId) {
            const index = fileQueue.findIndex(item => item.id === fileId);
            if (index > -1) {
                // Remove tab if exists
                const tab = document.getElementById(`tab_${fileId}`);
                if (tab) {
                    if (tab.classList.contains('active')) {
                        // Switch to another tab or hide results
                        const otherTabs = document.querySelectorAll('.file-tab');
                        if (otherTabs.length > 1) {
                            const nextTab = Array.from(otherTabs).find(t => t.id !== `tab_${fileId}`);
                            if (nextTab) {
                                switchToTab(nextTab.id.replace('tab_', ''));
                            }
                        } else {
                            hideResults();
                        }
                    }
                    tab.remove();
                    document.getElementById(`content_${fileId}`).remove();
                }
                
                fileQueue.splice(index, 1);
                document.getElementById(fileId).remove();
                
                // Update process all button
                const processAllBtn = document.getElementById('processAllBtn');
                if (processAllBtn) {
                    const pendingCount = fileQueue.filter(f => f.status === 'pending').length;
                    processAllBtn.textContent = `üöÄ Process All ${pendingCount} Files`;
                }
                
                // Hide queue if empty
                if (fileQueue.length === 0) {
                    document.getElementById('fileQueue').remove();
                    removeFile(); // Reset to initial state
                }
            }
        }

        function createFileTab(fileItem) {
            const tabsContainer = document.getElementById('fileTabs');
            const tabContents = document.getElementById('tabContents');
            
            // Show tabs if hidden
            tabsContainer.style.display = 'flex';
            
            // Create tab
            const tab = document.createElement('button');
            tab.className = 'file-tab';
            tab.id = `tab_${fileItem.id}`;
            tab.textContent = fileItem.file.name;
            tab.onclick = () => switchToTab(fileItem.id);
            tabsContainer.appendChild(tab);
            
            // Create tab content
            const tabContent = document.createElement('div');
            tabContent.className = 'tab-content';
            tabContent.id = `content_${fileItem.id}`;
            tabContents.appendChild(tabContent);
            
            // Populate content
            populateTabContent(fileItem, tabContent);
            
            // Switch to this tab
            switchToTab(fileItem.id);
        }

        function switchToTab(fileId) {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.file-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Activate selected tab and content
            const tab = document.getElementById(`tab_${fileId}`);
            const content = document.getElementById(`content_${fileId}`);
            
            if (tab && content) {
                tab.classList.add('active');
                content.classList.add('active');
                activeTab = fileId;
                
                // Update live filtering for this tab's content
                const fileItem = fileQueue.find(item => item.id === fileId);
                if (fileItem && fileItem.data) {
                    lastProcessedData = fileItem.data;
                }
            }
        }

        function populateTabContent(fileItem, tabElement) {
            // Create individual results section for this file
            tabElement.innerHTML = `
                <div class="results-section" style="display: block; margin: 0;">
                    <div class="summary-section" id="summarySection_${fileItem.id}" style="display: none;">
                        <div class="summary-header">üß† Smart Analysis</div>
                        <div id="summaryContent_${fileItem.id}"></div>
                    </div>
                    
                    <div class="tags-section" id="tagsSection_${fileItem.id}" style="display: none;">
                        <strong>Tags:</strong>
                        <div id="tagsContent_${fileItem.id}"></div>
                    </div>
                    
                    <div class="results-header">
                        <strong>üîç Analyzed Log Output</strong>
                    </div>
                    <div class="results-content" id="resultsContent_${fileItem.id}"></div>
                    
                    <div class="metadata-section" id="metadataSection_${fileItem.id}"></div>
                </div>
            `;
            
            // Populate with data
            displayResultsInTab(fileItem);
        }

        function displayResultsInTab(fileItem) {
            const data = fileItem.data;
            if (!data) return;
            
            const showSummary = document.getElementById('summarize').checked;
            const showTags = document.getElementById('tags').checked;
            const showFormatting = document.getElementById('highlight').checked;
            
            const resultsContent = document.getElementById(`resultsContent_${fileItem.id}`);
            const summarySection = document.getElementById(`summarySection_${fileItem.id}`);
            const summaryContent = document.getElementById(`summaryContent_${fileItem.id}`);
            const tagsSection = document.getElementById(`tagsSection_${fileItem.id}`);
            const tagsContent = document.getElementById(`tagsContent_${fileItem.id}`);
            const metadataSection = document.getElementById(`metadataSection_${fileItem.id}`);
            
            // Display formatted log
            if (showFormatting) {
                const formattedLog = formatLogOutput(data.cleaned_log);
                resultsContent.innerHTML = formattedLog;
                resultsContent.classList.remove('plain-mode');
            } else {
                const plainLog = formatPlainLogOutput(data.cleaned_log);
                resultsContent.innerHTML = plainLog;
                resultsContent.classList.add('plain-mode');
            }
            
            // Display summary conditionally
            if (showSummary && data.summary) {
                summarySection.style.display = 'block';
                summaryContent.textContent = data.summary;
            } else {
                summarySection.style.display = 'none';
            }
            
            // Display tags conditionally
            if (showTags && data.tags && data.tags.length > 0) {
                tagsSection.style.display = 'block';
                tagsContent.innerHTML = data.tags.map((tag, index) => 
                    `<span class="tag" onclick="toggleTagHighlight('${escapeHtml(tag)}', this)" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)}</span>`
                ).join('');
            } else {
                tagsSection.style.display = 'none';
            }
            
            // Display metadata
            const metadata = data.metadata;
            metadataSection.innerHTML = `
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.filename}</div>
                    <div class="metadata-label">Filename</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${formatFileSize(metadata.file_size)}</div>
                    <div class="metadata-label">File Size</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.lines}</div>
                    <div class="metadata-label">Lines</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.language_detected}</div>
                    <div class="metadata-label">Language</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">${metadata.processing_time_ms}ms</div>
                    <div class="metadata-label">Processing Time</div>
                </div>
                <div class="metadata-item">
                    <div class="metadata-value">Individual</div>
                    <div class="metadata-label">Processing Mode</div>
                </div>
            `;
        }

        function viewFileResults(fileId) {
            const fileItem = fileQueue.find(item => item.id === fileId);
            if (fileItem && fileItem.data) {
                // Create tab if it doesn't exist
                if (!document.getElementById(`tab_${fileId}`)) {
                    createFileTab(fileItem);
                } else {
                    switchToTab(fileId);
                }
            }
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant manager clearing away the dining area
        when it's time to reset for new customers. When someone wants to start
        fresh or there's no meal to display, this function:
        - Closes the dining room curtains (hides results)
        - Puts away the menu tabs (hides file tabs)
        - Prepares for the next dining experience
        
        Think of it like the "closed for cleaning" moment between customers
        when everything gets tidied up and put away.
        */
        function hideResults() {
            // üé≠ CLOSE THE DINING ROOM - Hide the main results display
            // Like drawing curtains over the dining area when no meal is being served
            resultsSection.style.display = 'none';
            
            // üìë PUT AWAY MENUS - Hide the tab navigation as well
            // Like collecting all the menus and putting them away until needed again
            const fileTabs = document.getElementById('fileTabs');
            if (fileTabs) {
                fileTabs.style.display = 'none';
            }
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant manager politely informing customers
        about any problems with their order. Instead of ignoring issues or
        letting customers wonder what went wrong, this function displays
        a clear, helpful message explaining what happened.
        
        Think of it like a good waiter coming to your table to say "I'm sorry,
        but we're out of salmon tonight. Would you like to try something else?"
        */
        function showError(message) {
            // üìù PROBLEM NOTIFICATION - Write down the issue for the customer to see
            // Like a waiter writing "Kitchen issue" on a note and showing it politely
            errorMessage.textContent = message;
            
            // üö® DISPLAY ALERT - Make the problem message visible
            // Like putting up a small, polite sign that says "We're working on this issue"
            errorMessage.style.display = 'block';
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function clears away any error messages when they're no longer needed.
        Like removing the "Sorry for the inconvenience" sign after the problem
        is fixed and service returns to normal.
        */
        function hideError() {
            // üßπ CLEAR PROBLEM DISPLAY - Remove the error message from view
            // Like taking down the "temporarily out of service" sign when everything's working again
            errorMessage.style.display = 'none';
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a restaurant's food safety protocol that makes sure
        no harmful "ingredients" (dangerous HTML code) get mixed into the "meal"
        (web page display). When customers send text that might contain special
        characters, this function "sanitizes" it to prevent any security problems.
        
        Think of it like washing vegetables before serving - you want to make sure
        everything is safe and clean before it goes to the customer.
        */
        function escapeHtml(text) {
            // üßº FOOD SAFETY SANITIZATION - Clean the text to prevent contamination
            // Like washing ingredients before cooking to remove any harmful substances
            const div = document.createElement('div');  // Create a clean "prep station"
            div.textContent = text;                     // Put the text through the "washing process"
            return div.innerHTML;                       // Return the clean, safe version
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a smart waiter who can instantly tell customers
        "Your file is about the size of a photo" instead of saying "Your file
        is 2,547,392 bytes." It converts technical numbers into human-friendly
        descriptions that anyone can understand.
        
        Think of it like translating computer language into normal conversation -
        instead of "1048576 bytes" it says "1 MB" which people recognize.
        */
        function formatFileSize(bytes) {
            // ü§è ZERO SIZE CHECK - Handle the "empty plate" case
            // Like recognizing when there's literally nothing to measure
            if (bytes === 0) return '0 Bytes';
            
            // üìè MEASUREMENT SYSTEM - Set up our "portion size" categories
            // Like having small, medium, large, and super-size portion descriptions
            const k = 1024;  // Computer counting system (like how we count by 10s, computers count by 1024s)
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];  // Portion size names from tiny to huge
            
            // üßÆ SMART CALCULATION - Figure out which "portion size" category fits best
            // Like a waiter automatically knowing to say "large" instead of "847 grams"
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            
            // üè∑Ô∏è FRIENDLY DESCRIPTION - Convert to human-readable portion size
            // Like saying "2.5 MB" instead of "2,621,440 bytes"
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        /*
        üèÜ HIGH SCHOOL EXPLANATION:
        This function is like a smart restaurant server who can instantly
        change how your meal is presented based on your preferences. When
        you tap a button (like "make it spicy" or "hold the onions"), this
        function:
        1. Checks what you currently prefer (checkbox state)
        2. Switches to the opposite preference (toggle)
        3. Updates the button to show your new choice (visual feedback)
        4. If you already have food, instantly re-plates it with your new preference
        
        Think of it like those modern restaurants where you can instantly
        customize your meal presentation - tap "colorful" and your food
        gets beautiful garnishes, tap it again and it goes back to simple.
        */
        function toggleOption(optionId, buttonElement) {
            // üîç PREFERENCE CHECK - See what the customer currently wants
            // Like checking a customer's order card to see their current preferences
            const checkbox = document.getElementById(optionId);
            const isCurrentlyChecked = checkbox.checked;
            
            // üîÑ PREFERENCE FLIP - Switch to the opposite choice
            // Like changing "yes please" to "no thanks" or vice versa
            checkbox.checked = !isCurrentlyChecked;
            
            // üí° VISUAL FEEDBACK - Update the button to show the new choice
            // Like a smart button that lights up when active, dims when inactive
            if (checkbox.checked) {
                buttonElement.classList.add('active');      // Light up the button (feature ON)
            } else {
                buttonElement.classList.remove('active');   // Dim the button (feature OFF)
            }
            
            // üîÑ INSTANT RE-PLATING - If there's already food, re-present it with new style
            // Like instantly changing how your meal looks without cooking it again
            if (lastProcessedData) {
                liveReprocess();  // Re-style the existing results with new preferences
            }
        }
    </script>
</body>
</html>