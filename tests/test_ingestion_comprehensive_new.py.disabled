"""
Comprehensive tests for ingestion.py focusing on log ingestion and processing pipeline.
Following Debuggle's quality-first testing philosophy.

Target: 75%+ coverage focusing on:
- Log ingestion workflows
- Data processing and validation
- Real file processing scenarios
- Error handling in ingestion pipeline
"""

import pytest
import tempfile
import os
import json
from datetime import datetime
from unittest.mock import patch, MagicMock, mock_open
from io import StringIO

# Import what's actually available
from src.debuggle.services.ingestion import IngestionEngine, get_ingestion_engine, initialize_ingestion_engine
from src.debuggle.models import AnalyzeRequest, LanguageEnum


class TestLogIngestionManager:
    """Test log ingestion manager functionality."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_ingestion_manager_initialization(self):
        """Test ingestion manager initializes correctly."""
        assert self.ingestion_manager is not None
        assert hasattr(self.ingestion_manager, 'processor')
    
    def test_ingest_single_log_entry(self):
        """Test ingesting a single log entry - core user workflow."""
        log_content = "ERROR: Failed to connect to database on localhost:5432"
        
        result = self.ingestion_manager.ingest_log(log_content)
        
        assert result is not None
        assert hasattr(result, 'status') or isinstance(result, dict)
    
    def test_ingest_python_error_log(self):
        """Test ingesting Python error logs - common use case."""
        python_error = """
Traceback (most recent call last):
  File "app.py", line 42, in main
    result = process_data(user_input)
  File "app.py", line 23, in process_data
    return data[index]
IndexError: list index out of range
        """
        
        result = self.ingestion_manager.ingest_log(python_error, language="python")
        
        assert result is not None
        # Should identify the error type
        if hasattr(result, 'error_type'):
            assert "index" in result.error_type.lower()
    
    def test_ingest_javascript_error_log(self):
        """Test ingesting JavaScript error logs."""
        js_error = "TypeError: Cannot read property 'length' of undefined"
        
        result = self.ingestion_manager.ingest_log(js_error, language="javascript")
        
        assert result is not None
        # Should handle JavaScript syntax
        assert result  # Basic non-null check
    
    def test_ingest_java_error_log(self):
        """Test ingesting Java error logs."""
        java_error = "java.lang.NullPointerException: null at com.example.MyClass.method(MyClass.java:42)"
        
        result = self.ingestion_manager.ingest_log(java_error, language="java")
        
        assert result is not None
        # Should handle Java stack traces
        assert result
    
    def test_ingest_empty_log(self):
        """Test handling empty log input."""
        result = self.ingestion_manager.ingest_log("")
        
        # Should handle gracefully, not crash
        assert result is not None or result is None
    
    def test_ingest_very_long_log(self):
        """Test handling very long log entries."""
        long_log = "Error occurred: " + "data " * 10000  # Very long log
        
        result = self.ingestion_manager.ingest_log(long_log)
        
        # Should handle without crashing
        assert result is not None or result is None
    
    def test_ingest_log_with_special_characters(self):
        """Test ingesting logs with special characters and unicode."""
        special_log = "Error: Cannot parse JSON {\"key\": \"vålue with 特殊字符\"} at line 15"
        
        result = self.ingestion_manager.ingest_log(special_log)
        
        # Should handle special characters without crashing
        assert result is not None or result is None


class TestFileIngestion:
    """Test file-based log ingestion workflows."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_ingest_log_file(self):
        """Test ingesting log file - important user workflow."""
        log_content = """
[2024-10-03 10:30:15] ERROR: Database connection failed
[2024-10-03 10:30:16] ERROR: Retrying connection... (attempt 1/3)  
[2024-10-03 10:30:17] ERROR: Connection timeout after 30 seconds
[2024-10-03 10:30:18] FATAL: Unable to establish database connection
        """
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.log', delete=False) as f:
            f.write(log_content)
            f.flush()
            temp_path = f.name
        
        try:
            result = self.ingestion_manager.ingest_file(temp_path)
            
            assert result is not None
            # Should process multiple log lines
            if hasattr(result, 'entries'):
                assert len(result.entries) > 0
            
        finally:
            os.unlink(temp_path)
    
    def test_ingest_large_log_file(self):
        """Test ingesting large log files - performance test."""
        # Create a larger log file
        log_lines = []
        for i in range(1000):
            log_lines.append(f"[2024-10-03 10:{i%60:02d}:00] ERROR: Error number {i}")
        
        log_content = "\n".join(log_lines)
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.log', delete=False) as f:
            f.write(log_content)
            f.flush()
            temp_path = f.name
        
        try:
            result = self.ingestion_manager.ingest_file(temp_path)
            
            # Should handle large files without timeout
            assert result is not None
            
        finally:
            os.unlink(temp_path)
    
    def test_ingest_nonexistent_file(self):
        """Test handling of nonexistent files."""
        nonexistent_path = "/path/that/does/not/exist.log"
        
        try:
            result = self.ingestion_manager.ingest_file(nonexistent_path)
            # Should either return None/error result or raise exception
            assert result is None or hasattr(result, 'error')
        except (FileNotFoundError, IOError):
            # Exception is acceptable for nonexistent files
            pass
    
    def test_ingest_empty_file(self):
        """Test ingesting empty log file."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.log', delete=False) as f:
            temp_path = f.name
        
        try:
            result = self.ingestion_manager.ingest_file(temp_path)
            
            # Should handle empty files gracefully
            assert result is not None or result is None
            
        finally:
            os.unlink(temp_path)
    
    def test_ingest_binary_file(self):
        """Test handling binary files - error scenario."""
        binary_content = b'\x89PNG\r\n\x1a\n'  # PNG header
        
        with tempfile.NamedTemporaryFile(delete=False) as f:
            f.write(binary_content)
            f.flush()
            temp_path = f.name
        
        try:
            result = self.ingestion_manager.ingest_file(temp_path)
            
            # Should handle binary files gracefully (reject or convert)
            assert result is not None or result is None
            
        finally:
            os.unlink(temp_path)


class TestLogFormatDetection:
    """Test automatic log format detection."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_detect_apache_log_format(self):
        """Test detecting Apache log format."""
        apache_log = '127.0.0.1 - - [03/Oct/2024:10:30:15 +0000] "GET /index.html HTTP/1.1" 200 1024'
        
        result = self.ingestion_manager.ingest_log(apache_log)
        
        # Should handle Apache log format
        assert result is not None
    
    def test_detect_nginx_log_format(self):
        """Test detecting Nginx log format."""
        nginx_log = '127.0.0.1 - - [03/Oct/2024:10:30:15 +0000] "GET /api/status HTTP/1.1" 500 234 "-" "curl/7.68.0"'
        
        result = self.ingestion_manager.ingest_log(nginx_log)
        
        # Should handle Nginx log format
        assert result is not None
    
    def test_detect_syslog_format(self):
        """Test detecting syslog format."""
        syslog_entry = "Oct  3 10:30:15 hostname myapp[1234]: ERROR: Connection failed"
        
        result = self.ingestion_manager.ingest_log(syslog_entry)
        
        # Should handle syslog format
        assert result is not None
    
    def test_detect_json_log_format(self):
        """Test detecting JSON log format."""
        json_log = '{"timestamp":"2024-10-03T10:30:15Z","level":"ERROR","message":"Database connection failed","component":"auth-service"}'
        
        result = self.ingestion_manager.ingest_log(json_log)
        
        # Should handle JSON format
        assert result is not None
    
    def test_detect_csv_log_format(self):
        """Test detecting CSV log format."""
        csv_log = "2024-10-03 10:30:15,ERROR,Database,Connection failed,auth-service"
        
        result = self.ingestion_manager.ingest_log(csv_log)
        
        # Should handle CSV format
        assert result is not None


class TestIngestionErrorHandling:
    """Test error handling in ingestion process."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_malformed_log_input(self):
        """Test handling malformed log input."""
        malformed_logs = [
            None,  # Null input
            123,   # Non-string input
            {"invalid": "object"},  # Dictionary instead of string
            [],    # List instead of string
        ]
        
        for malformed_log in malformed_logs:
            try:
                result = self.ingestion_manager.ingest_log(malformed_log)
                # Should handle gracefully or return error
                assert result is None or hasattr(result, 'error')
            except (TypeError, ValueError):
                # Raising appropriate exceptions is acceptable
                pass
    
    @patch('src.debuggle.processor.LogProcessor.process_log')
    def test_processor_failure_handling(self, mock_process):
        """Test handling processor failures."""
        mock_process.side_effect = Exception("Processor failed")
        
        result = self.ingestion_manager.ingest_log("Test error log")
        
        # Should handle processor failures gracefully
        assert result is None or hasattr(result, 'error')
    
    def test_memory_limit_handling(self):
        """Test handling very large log inputs."""
        # Create extremely large log (but not too large for testing)
        huge_log = "ERROR: " + "x" * 1000000  # 1MB of text
        
        try:
            result = self.ingestion_manager.ingest_log(huge_log)
            # Should either process or reject gracefully
            assert result is not None or result is None
        except MemoryError:
            # Memory errors are acceptable for huge inputs
            pass
    
    def test_encoding_error_handling(self):
        """Test handling encoding errors in log input."""
        # Simulate logs with encoding issues
        problematic_logs = [
            "Error: Invalid UTF-8 \xff\xfe sequence",
            "Warning: Mixed encoding \xe9\x81\x93 characters",
        ]
        
        for log in problematic_logs:
            try:
                result = self.ingestion_manager.ingest_log(log)
                # Should handle encoding issues gracefully
                assert result is not None or result is None
            except UnicodeError:
                # Unicode errors are acceptable
                pass


class TestIngestionMetadata:
    """Test metadata extraction during ingestion."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_extract_timestamp_metadata(self):
        """Test extracting timestamp information."""
        timestamped_log = "[2024-10-03 10:30:15] ERROR: Connection failed"
        
        result = self.ingestion_manager.ingest_log(timestamped_log)
        
        assert result is not None
        # Should extract timestamp if possible
        if hasattr(result, 'timestamp'):
            assert result.timestamp is not None
    
    def test_extract_severity_metadata(self):
        """Test extracting log severity levels."""
        severity_logs = [
            "DEBUG: Verbose debugging information",
            "INFO: Process started successfully", 
            "WARNING: Deprecated function used",
            "ERROR: Connection timeout",
            "CRITICAL: System failure detected"
        ]
        
        for log in severity_logs:
            result = self.ingestion_manager.ingest_log(log)
            
            assert result is not None
            # Should identify severity level
            if hasattr(result, 'severity'):
                assert result.severity is not None
    
    def test_extract_component_metadata(self):
        """Test extracting component/service information."""
        component_log = "[auth-service] ERROR: Unable to validate user token"
        
        result = self.ingestion_manager.ingest_log(component_log)
        
        assert result is not None
        # Should identify component if present
        if hasattr(result, 'component'):
            assert "auth" in result.component.lower()
    
    def test_extract_file_location_metadata(self):
        """Test extracting file and line number information."""
        location_log = "ERROR in /app/models/user.py:142 - Invalid user ID format"
        
        result = self.ingestion_manager.ingest_log(location_log)
        
        assert result is not None
        # Should extract file location if present
        if hasattr(result, 'location'):
            assert "user.py" in result.location


class TestIngestionIntegration:
    """Test ingestion integration with other components."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    @patch('src.debuggle.storage.database.DatabaseManager')
    def test_database_integration(self, mock_db):
        """Test ingestion integration with database storage."""
        mock_db_instance = MagicMock()
        mock_db.return_value = mock_db_instance
        
        log_content = "ERROR: Database query failed"
        result = self.ingestion_manager.ingest_log(log_content)
        
        # Should integrate with database for storage
        assert result is not None
    
    def test_processor_integration(self):
        """Test ingestion integration with log processor."""
        complex_log = """
        Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
        at MyClass.main(MyClass.java:10)
        at java.base/java.lang.Thread.run(Thread.java:834)
        """
        
        result = self.ingestion_manager.ingest_log(complex_log)
        
        # Should process complex logs through processor
        assert result is not None
    
    @patch('src.debuggle.realtime.WebSocketManager')
    def test_realtime_integration(self, mock_ws):
        """Test ingestion integration with real-time notifications."""
        mock_ws_instance = MagicMock()
        mock_ws.return_value = mock_ws_instance
        
        critical_log = "CRITICAL: System is out of memory"
        result = self.ingestion_manager.ingest_log(critical_log)
        
        # Should trigger real-time notifications for critical logs
        assert result is not None


class TestIngestionConfiguration:
    """Test ingestion configuration and settings."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_configure_ingestion_rules(self):
        """Test configuring ingestion rules and filters."""
        # Test with configuration
        config = {
            "ignore_debug": True,
            "max_line_length": 1000,
            "extract_metadata": True
        }
        
        result = self.ingestion_manager.configure(config)
        
        # Should accept configuration
        assert result is not None or result is None
    
    def test_ingestion_with_custom_parser(self):
        """Test ingestion with custom log parser."""
        custom_format_log = "TIMESTAMP|LEVEL|COMPONENT|MESSAGE"
        
        result = self.ingestion_manager.ingest_log(
            custom_format_log, 
            format_hint="custom_pipe_delimited"
        )
        
        # Should handle custom formats
        assert result is not None
    
    @patch.dict(os.environ, {'DEBUGGLE_INGESTION_MODE': 'strict'})
    def test_strict_mode_ingestion(self):
        """Test ingestion in strict validation mode."""
        questionable_log = "Maybe this is an error?"
        
        result = self.ingestion_manager.ingest_log(questionable_log)
        
        # Should apply strict validation
        assert result is not None or result is None


class TestIngestionPerformance:
    """Test ingestion performance and efficiency."""
    
    def setup_method(self):
        """Set up ingestion manager for each test."""
        self.ingestion_manager = LogIngestionManager()
    
    def test_batch_ingestion(self):
        """Test batch processing of multiple logs."""
        log_batch = [
            "ERROR: First error occurred",
            "WARNING: Second warning issued", 
            "INFO: Third info message logged",
            "ERROR: Fourth error detected"
        ]
        
        result = self.ingestion_manager.ingest_batch(log_batch)
        
        # Should process batch efficiently
        assert result is not None
        if hasattr(result, 'processed_count'):
            assert result.processed_count > 0
    
    def test_streaming_ingestion(self):
        """Test streaming log ingestion."""
        log_stream = StringIO("""
ERROR: Streaming error 1
WARNING: Streaming warning 1  
ERROR: Streaming error 2
INFO: Streaming info 1
        """)
        
        result = self.ingestion_manager.ingest_stream(log_stream)
        
        # Should process stream efficiently
        assert result is not None
    
    def test_concurrent_ingestion(self):
        """Test concurrent log ingestion."""
        import concurrent.futures
        
        def ingest_log(i):
            return self.ingestion_manager.ingest_log(f"ERROR: Concurrent error {i}")
        
        # Test concurrent ingestion
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(ingest_log, i) for i in range(10)]
            results = [future.result() for future in futures]
        
        # All ingestions should complete
        for result in results:
            assert result is not None or result is None


if __name__ == "__main__":
    pytest.main([__file__, "-v"])