#
# üìã DEBUGGLE PROJECT BLUEPRINT - The Master Configuration Document
# =================================================================
#
# This pyproject.toml file is like the "birth certificate" and "building permit"
# for our Python project all rolled into one official document. It tells the
# Python ecosystem everything it needs to know about our software package.
#
# üèÜ HIGH SCHOOL EXPLANATION:
# Think of this like the comprehensive information packet you need when:
# - Registering for college (personal info, requirements, what you're studying)
# - Getting a business license (company name, what you do, who you are)  
# - Publishing a book (title, author, description, ISBN, what stores can sell it)
#
# This file serves all those purposes for our Python software:
# - Identity (name, version, author)
# - Requirements (what Python versions, what libraries)
# - Capabilities (what it does, who should use it)
# - Distribution (how to package and install it)
#
# EDUCATIONAL METAPHORS USED:
# üìã Official Documentation - Birth certificates, business licenses, permits
# üèóÔ∏è Construction Planning - Blueprints, building codes, material specifications
# üìö Publishing - Book metadata, ISBN systems, library cataloging
# üè™ Product Packaging - Nutrition labels, ingredient lists, safety information
#

#
# üè≠ BUILD SYSTEM SPECIFICATION - The manufacturing instructions
# =============================================================
#
# This section tells Python's packaging system which tools to use when
# building our software for distribution, like specifying which factory
# equipment and assembly line process to use for manufacturing.
#
[build-system]
requires = ["setuptools>=61.0", "wheel"]    # üîß Required factory equipment (build tools)
build-backend = "setuptools.build_meta"     # üè≠ Which assembly line process to use

#
# üÜî PROJECT IDENTITY - The official product information
# ======================================================
#
# This section is like the product label on a consumer good - it contains
# all the essential information that identifies our software and tells
# people what it is, who made it, and what it does.
#
[project]
# üè∑Ô∏è PRODUCT IDENTIFICATION - Official name and version
name = "debuggle-core"                       # üì¶ Official package name (like product SKU)
version = "1.0.0"                           # üî¢ Version number (like model year)

# üë• CREATOR INFORMATION - Who built this software
authors = [
    {name = "Mike Smith", email = "mike@debuggle.com"},
]

# üìù PRODUCT DESCRIPTION - What this software does
description = "Intelligent error analysis that beats copy/pasting into ChatGPT"

# üìö DOCUMENTATION REFERENCES - Where to find more information
readme = "README.md"                        # üìñ Main instruction manual
license = {file = "LICENSE"}                # ‚öñÔ∏è Legal terms and conditions

# üêç SYSTEM REQUIREMENTS - What Python versions this works with
requires-python = ">=3.9"                   # üîß Minimum Python version needed
#
# üè™ PRODUCT CATEGORIZATION - Store shelf placement and target audience
# =====================================================================
#
# Classifiers are like the category tags in an app store or the aisle
# placement in a supermarket. They help people find our software when
# they're looking for solutions to specific problems.
#
classifiers = [
    # üöß DEVELOPMENT MATURITY - How finished/stable is this software?
    "Development Status :: 4 - Beta",                    # üß™ Beta = mostly done, testing phase
    
    # üë• TARGET AUDIENCE - Who should use this?
    "Intended Audience :: Developers",                   # üíª Built for programmers and dev teams
    
    # ‚öñÔ∏è LEGAL FRAMEWORK - What are the usage rights?
    "License :: OSI Approved :: MIT License",            # üìÑ MIT = very permissive, business-friendly
    
    # üíª PLATFORM COMPATIBILITY - What systems does this run on?
    "Operating System :: OS Independent",                # üåç Works on Windows, Mac, Linux
    
    # üêç PROGRAMMING LANGUAGE SUPPORT - Python version compatibility
    "Programming Language :: Python :: 3",              # üêç Python 3.x series
    "Programming Language :: Python :: 3.9",            # ‚úÖ Supports Python 3.9
    "Programming Language :: Python :: 3.10",           # ‚úÖ Supports Python 3.10
    "Programming Language :: Python :: 3.11",           # ‚úÖ Supports Python 3.11
    "Programming Language :: Python :: 3.12",           # ‚úÖ Supports Python 3.12
    
    # üéØ PROBLEM DOMAIN - What category of problems does this solve?
    "Topic :: Software Development :: Debuggers",        # üêõ Debugging and error analysis tools
    "Topic :: Software Development :: Quality Assurance", # ‚úÖ Code quality and testing tools
]

#
# üîç SEARCH KEYWORDS - How people will find our software
# ======================================================
#
# These are like hashtags or SEO keywords that help people discover our
# software when they search for solutions. Think of them like the tags
# on a YouTube video or Instagram post.
#
keywords = ["debugging", "error-analysis", "logging", "development-tools", "chatgpt-alternative"]

#
# üì¶ DEPENDENCY MANIFEST - What other software packages we need
# ============================================================
#
# This is like the ingredients list on a recipe or the parts list for
# building a complex machine. Our software depends on these other
# packages to function properly.
#
# üèÜ HIGH SCHOOL EXPLANATION:
# Think of this like planning a complex school project:
# - You need specific supplies (libraries) to complete different parts
# - Some supplies have minimum quality requirements (version numbers)
# - If you're missing any supply, the project won't work properly
#
dependencies = [
    # üåê WEB SERVER FOUNDATION - The core web service framework
    "fastapi>=0.68.0",              # üöÄ Modern, fast web API framework (like Express.js for Python)
    "uvicorn[standard]>=0.15.0",     # ‚ö° High-performance web server (runs our FastAPI app)
    
    # üìã DATA VALIDATION & SETTINGS - Ensuring data quality and configuration
    "pydantic>=2.0.0",              # ‚úÖ Data validation and serialization (like form validation)
    "pydantic-settings>=2.0.0",     # ‚öôÔ∏è Configuration management (reading settings files)
    
    # üé® TEXT PROCESSING & DISPLAY - Making code and errors look good
    "pygments>=2.9.0",              # üåà Syntax highlighting for code (like VS Code colors)
    "rich>=12.0.0",                 # üì∫ Beautiful terminal output with colors and formatting
    
    # üö¶ TRAFFIC CONTROL & FILE HANDLING - Managing requests and uploads
    "slowapi>=0.1.7",               # üõ°Ô∏è Rate limiting (prevents server overload)
    "python-multipart>=0.0.5",      # üìÅ File upload handling (processes uploaded log files)
    
    # üåç LANGUAGE DETECTION - Identifying programming languages in logs
    "langdetect>=1.0.9",            # üîç Automatic language detection (Python vs Java vs etc.)
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-cov>=4.0.0",
    "pytest-asyncio>=0.21.0",
    "black>=22.0.0",
    "flake8>=5.0.0",
    "mypy>=1.0.0",
    "pre-commit>=2.20.0",
]
examples = [
    "flask>=2.3.0",
    "requests>=2.31.0",
]

[project.urls]
Homepage = "https://github.com/mikejsmtih1985/debuggle"
Documentation = "https://github.com/mikejsmtih1985/debuggle#readme"
Repository = "https://github.com/mikejsmtih1985/debuggle.git"
Issues = "https://github.com/mikejsmtih1985/debuggle/issues"

[project.scripts]
debuggle = "cli.debuggle_cli:main"

[tool.setuptools.packages.find]
where = ["src"]
include = ["debuggle*"]

[tool.setuptools.package-data]
debuggle = ["py.typed"]

# ===================================================================
# üé® CODE STYLE ENFORCEMENT - The Company Dress Code Manual
# ===================================================================
#
# üèÜ HIGH SCHOOL EXPLANATION:
# This section defines how our Python code should be formatted, like
# having a dress code at a professional business. Just like a company
# might say "shirts must be tucked in" or "no sneakers in the office",
# this tells our code formatter exactly how to make our code look
# professional and consistent.
#
[tool.black]
line-length = 100          # Like saying "keep sentences under 100 characters"
target-version = ['py39']   # The version of Python "language" we're writing in
include = '\.pyi?$'        # Which files to format (Python files ending in .py)
extend-exclude = '''       # Which folders to ignore (like "don't dress-code the janitor's closet")
/(
  # directories
  \.eggs          # Build artifacts (temporary files)
  | \.git         # Version control system files
  | \.hg          # Another version control system
  | \.mypy_cache  # Type checker cache
  | \.tox         # Testing environment cache
  | \.venv        # Virtual environment
  | build         # Build output folder
  | dist          # Distribution packages
)/
'''

# ===================================================================
# üß™ TESTING LABORATORY - Quality Control Department Settings
# ===================================================================
#
# üèÜ HIGH SCHOOL EXPLANATION:
# This section configures our automated testing system, like setting
# up the rules for a science lab. Just like a chemistry lab has safety
# protocols and procedures, this defines how our code tests should run
# to ensure everything works correctly before we ship to customers.
#
[tool.pytest.ini_options]
minversion = "7.0"          # Minimum version of our testing equipment required
addopts = [                 # Standard testing procedures (like lab safety rules)
    "--strict-markers",     # Be strict about test categories (like "label all chemicals")
    "--strict-config",      # Be strict about configuration (like "follow safety protocols exactly")
    "--cov=src/debuggle",   # Measure how much of our code gets tested (like quality control coverage)
    "--cov-report=term-missing",  # Show what's not tested in the terminal
    "--cov-report=html",    # Create a web report showing test coverage
    "--cov-branch",         # Test all code paths, not just lines
]
testpaths = ["tests"]       # Where to find our test procedures (like the lab manual location)
python_files = ["test_*.py"] # Which files contain tests (like "files starting with 'test_'")
python_classes = ["Test*"]      # Test classes should start with "Test"
python_functions = ["test_*"]  # Test functions should start with "test_"

# ===================================================================
# üìä QUALITY COVERAGE MEASUREMENT - Performance Audit Department
# ===================================================================
#
# üèÜ HIGH SCHOOL EXPLANATION:
# This section configures how we measure code coverage, like having
# auditors check what percentage of a business gets inspected during
# a quality review. We want to make sure our tests actually check
# most of our code, not just the easy parts.
#
[tool.coverage.run]
source = ["src/debuggle"]   # Which parts of our business to audit (like "check the main office")
branch = true               # Check all decision paths (like "audit both the 'yes' and 'no' choices")

[tool.coverage.report]
show_missing = true         # Point out what wasn't checked (like "highlight missed areas")
skip_covered = false        # Show everything, even fully-tested parts
fail_under = 89            # Require at least 89% coverage (like "we need 89% audit completion")

# ===================================================================
# üîç TYPE CHECKING SYSTEM - The Grammar Police Department
# ===================================================================
#
# üèÜ HIGH SCHOOL EXPLANATION:
# This section configures MyPy, which is like having a grammar checker
# for our code. Just like how a grammar checker catches when you use
# "their" instead of "there", MyPy catches when we use the wrong type
# of data (like trying to add a number to a word).
#
[tool.mypy]
python_version = "3.9"                # Which version of Python "grammar rules" to follow
warn_return_any = true              # Warn about vague return types (like "return something")
warn_unused_configs = true          # Point out unused settings (like unused grammar rules)
disallow_untyped_defs = true        # Require clear function signatures (like "declare what you do")
disallow_incomplete_defs = true     # Don't allow half-finished type hints
check_untyped_defs = true           # Check functions even without type hints
disallow_untyped_decorators = true  # Require type hints on decorators
no_implicit_optional = true         # Be explicit about optional parameters
warn_redundant_casts = true         # Point out unnecessary type conversions
warn_unused_ignores = true          # Warn about unused "ignore" comments
warn_no_return = true               # Warn about functions that should return something
warn_unreachable = true             # Point out code that can never be reached
strict_equality = true              # Be strict about comparing different types

# ===================================================================
# üìö EXTERNAL LIBRARY EXCEPTIONS - Foreign Language Department
# ===================================================================
#
# üèÜ HIGH SCHOOL EXPLANATION:
# Sometimes we use external libraries (code written by other people)
# that don't have proper type hints. This is like having foreign
# exchange students who speak different "grammar rules". Instead of
# failing our grammar check, we make exceptions for these specific
# libraries and trust that they work correctly.
#
[[tool.mypy.overrides]]
module = [
    "langdetect.*",         # Language detection library
    "pygments.*",          # Code syntax highlighting library  
    "slowapi.*",           # Rate limiting library
]
ignore_missing_imports = true   # Don't fail if these libraries lack type information