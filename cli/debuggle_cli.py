#!/usr/bin/env python3
"""
üîß DEBUGGLE SWISS ARMY KNIFE - The Professional's Portable Debugging Toolkit
============================================================================

This CLI (Command Line Interface) tool is like having a Swiss Army knife for
debugging - a compact, powerful, multi-tool that fits in your pocket and
handles most common debugging tasks without needing a full workshop setup.

üèÜ HIGH SCHOOL EXPLANATION:
Think of this like the difference between:
- üè™ FULL STORE EXPERIENCE: Going to a big department store (web interface)
  - Beautiful displays, helpful staff, comfortable environment
  - Great for browsing and complex tasks
  - Requires time to travel there and navigate

- üîß PORTABLE TOOLKIT: Using a Swiss Army knife (this CLI tool)
  - Instant access, no setup required
  - Perfect for quick fixes and emergencies
  - Works anywhere, anytime, in any environment
  - Integrates seamlessly with your existing workflow

üéØ WHY DEBUGGLE CLI BEATS COPY/PASTING TO CHATGPT:

üö´ OLD WORKFLOW (Copy/Paste to ChatGPT):
   1. Error occurs ‚Üí 2. Copy error text ‚Üí 3. Open browser ‚Üí 4. Paste to ChatGPT 
   5. Wait for response ‚Üí 6. Copy suggestion ‚Üí 7. Go back to code

‚úÖ NEW WORKFLOW (Debuggle CLI):
   1. Error occurs ‚Üí 2. Pipe directly: `python app.py 2>&1 | debuggle` ‚Üí 3. Get instant analysis

üî• PROFESSIONAL ADVANTAGES:
- üöÄ ZERO FRICTION: No copy/paste, no browser switching, no context loss
- üîê PRIVACY FORTRESS: Your code never leaves your computer - enterprise safe
- üß† CONTEXT AWARENESS: Sees your entire project structure and files
- ‚ö° WORKFLOW INTEGRATION: Works with any terminal, script, or automation
- üéØ PRECISION ANALYSIS: Understands your specific codebase and patterns

üõ†Ô∏è SWISS ARMY KNIFE TOOLS:
    debuggle error.log                    # üîç File analyzer tool
    python app.py 2>&1 | debuggle         # ‚ö° Live error interceptor (the magic!)
    debuggle --watch server.log           # üëÅÔ∏è Continuous monitoring tool
    debuggle --project /path/to/code      # üóÇÔ∏è Project context analyzer
    
EDUCATIONAL METAPHORS USED IN THIS FILE:
üîß Swiss Army Knife - Multi-purpose tool with many specialized functions
üë®‚Äçüîß Professional Toolkit - Organized collection of specialized instruments  
‚ö° Emergency Response - Quick response tools for urgent situations
üîç Detective Kit - Investigation tools for analyzing evidence
üì° Communication Hub - Connecting different systems and workflows
"""

#
# üß∞ TOOLKIT INVENTORY - Essential instruments for our debugging Swiss Army knife
# ===============================================================================
#
# Like a well-organized professional's toolkit, we need specific instruments
# for different aspects of command-line debugging and error analysis.
#
import argparse     # üéõÔ∏è Command interface controller (handles --help, --version, etc.)
import sys          # üîß System integration tools (stdin/stdout pipes, exit codes)
import os           # üóÇÔ∏è File system navigator (paths, directories, file operations)
from pathlib import Path        # üó∫Ô∏è Modern GPS for file and directory navigation
from typing import Optional     # üìã Code clarity enhancer (documents what might be None)

#
# üìç TOOLKIT LOCATION SETUP - Connecting to our main debugging arsenal
# ====================================================================
#
# This is like telling our Swiss Army knife where to find the main toolbox
# so it can access all the specialized debugging instruments and analysis engines.
#
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

#
# üî¨ SPECIALIZED ANALYSIS INSTRUMENTS - The core debugging engines
# ================================================================
#
# These are like importing the high-precision instruments from our main
# laboratory - the sophisticated analysis engines that do the actual
# error investigation and context extraction work.
#
from src.debuggle.core.processor import LogProcessor    # üß† Master error analysis engine
from src.debuggle.core.context import ContextExtractor  # üîç Project context detective


def analyze_error_from_file(log_file: str, project_root: Optional[str] = None):
    """
    üîç FILE FORENSICS ANALYZER - Professional error investigation from saved evidence
    
    This function is like a crime scene investigator who can analyze evidence
    (log files) to reconstruct what happened and provide expert analysis
    of the situation, complete with context and recommendations.
    
    üèÜ HIGH SCHOOL EXPLANATION:
    Think of this like being a detective investigating a case:
    1. üìÇ Open evidence file (log file) and read all the details
    2. üóÇÔ∏è Establish crime scene location (project directory context)
    3. üî¨ Deploy forensic analysis tools (LogProcessor)
    4. üìä Generate comprehensive investigation report
    5. üí° Provide actionable recommendations for resolution
    
    Args:
        log_file: Path to the evidence file (error log) to analyze
        project_root: The "crime scene" directory (defaults to current location)
    """
    try:
        # üìÇ EVIDENCE COLLECTION - Reading the case file
        with open(log_file, 'r', encoding='utf-8') as f:
            log_content = f.read()
        
        # üó∫Ô∏è CRIME SCENE ESTABLISHMENT - Setting investigation boundaries  
        if not project_root:
            project_root = os.getcwd()  # Use current directory as investigation zone
        
        # üî¨ FORENSIC LAB SETUP - Initialize analysis instruments
        processor = LogProcessor()
        
        # üì¢ INVESTIGATION ANNOUNCEMENT - Professional toolkit activation
        print("üöÄ Debuggle CLI - Better than copy/pasting into ChatGPT!")
        print("=" * 60)
        
        # Process with full context
        cleaned_log, summary, tags, metadata, rich_context = processor.process_log_with_context(
            log_input=log_content,
            project_root=project_root,
            highlight=False,  # Terminal friendly
            summarize=True,
            tags=True
        )
        
        print(rich_context)
        
        print("\n" + "=" * 60)
        print("üéØ Why this is better than ChatGPT:")
        print("  ‚úÖ Analyzed your actual project context")
        print("  ‚úÖ No data sent to external services") 
        print("  ‚úÖ Integrated into your development workflow")
        print("  ‚úÖ Automatic - no copy/paste required")
        
        return True
        
    except FileNotFoundError:
        print(f"‚ùå Error: Log file '{log_file}' not found")
        return False
    except Exception as e:
        print(f"‚ùå Error processing log: {e}")
        return False


def analyze_error_from_stdin():
    """Analyze error from stdin (pipe support)."""
    try:
        log_content = sys.stdin.read()
        
        if not log_content.strip():
            print("‚ùå No input provided")
            return False
        
        project_root = os.getcwd()
        processor = LogProcessor()
        
        print("üöÄ Debuggle CLI - Analyzing piped error...")
        print("=" * 50)
        
        # Process with context
        cleaned_log, summary, tags, metadata, rich_context = processor.process_log_with_context(
            log_input=log_content,
            project_root=project_root,
            highlight=False,
            summarize=True,
            tags=True
        )
        
        print(rich_context)
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error processing input: {e}")
        return False


def watch_log_file(log_file: str, project_root: Optional[str] = None):
    """Watch a log file for new errors (basic implementation)."""
    print(f"üëÄ Watching {log_file} for new errors...")
    print("This demonstrates workflow integration - something ChatGPT can't do!")
    print("Press Ctrl+C to stop")
    
    try:
        import time
        last_size = 0
        
        while True:
            try:
                current_size = os.path.getsize(log_file)
                if current_size > last_size:
                    # New content added
                    with open(log_file, 'r') as f:
                        f.seek(last_size)
                        new_content = f.read()
                    
                    if 'error' in new_content.lower() or 'exception' in new_content.lower():
                        print(f"\nüö® New error detected at {time.strftime('%H:%M:%S')}")
                        analyze_error_from_stdin_content(new_content, project_root)
                    
                    last_size = current_size
                
                time.sleep(1)
                
            except FileNotFoundError:
                print(f"‚è≥ Waiting for {log_file} to be created...")
                time.sleep(5)
                
    except KeyboardInterrupt:
        print("\nüëã Stopped watching log file")


def analyze_error_from_stdin_content(content: str, project_root: Optional[str] = None):
    """Helper to analyze content with context."""
    try:
        if not project_root:
            project_root = os.getcwd()
            
        processor = LogProcessor()
        
        cleaned_log, summary, tags, metadata, rich_context = processor.process_log_with_context(
            log_input=content,
            project_root=project_root,
            highlight=False,
            summarize=True,
            tags=True
        )
        
        print(rich_context)
        
    except Exception as e:
        print(f"‚ùå Error: {e}")


def main():
    """Main CLI interface."""
    parser = argparse.ArgumentParser(
        description="Debuggle CLI - Better error analysis than copy/pasting into ChatGPT",
        epilog="""
Examples:
  debuggle error.log                    # Analyze log file
  debuggle -p /path/to/project error.log # Analyze with specific project root
  python app.py 2>&1 | debuggle         # Pipe errors directly
  debuggle --watch server.log           # Watch log file for new errors
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('logfile', nargs='?', help='Log file to analyze')
    parser.add_argument('-p', '--project-root', help='Project root directory for context')
    parser.add_argument('-w', '--watch', action='store_true', help='Watch log file for new errors')
    parser.add_argument('--version', action='version', version='Debuggle CLI 1.0.0')
    
    args = parser.parse_args()
    
    # Show help if no arguments
    if not args.logfile and sys.stdin.isatty():
        parser.print_help()
        return
    
    success = False
    
    if args.watch and args.logfile:
        # Watch mode
        watch_log_file(args.logfile, args.project_root)
        success = True
        
    elif args.logfile:
        # Analyze file
        success = analyze_error_from_file(args.logfile, args.project_root)
        
    elif not sys.stdin.isatty():
        # Analyze from stdin (piped input)
        success = analyze_error_from_stdin()
        
    else:
        parser.print_help()
        
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()