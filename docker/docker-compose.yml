#
# ğŸ—ï¸ DEBUGGLE SERVICE ORCHESTRATION - Multi-Container System Coordinator
# =======================================================================
#
# This docker-compose.yml file is like the master plan for a complex facility
# that coordinates multiple specialized buildings, utilities, and services
# to work together as a unified system.
#
# ğŸ† HIGH SCHOOL EXPLANATION:
# Think of this like planning a shopping mall or campus:
# 1. You need different specialized buildings (containers/services)
# 2. Each building needs utilities (ports, volumes, networks)
# 3. Buildings need to communicate with each other (networking)
# 4. You need backup plans if something breaks (restart policies)
# 5. You need to monitor that everything is working (health checks)
#
# Docker Compose orchestrates all these pieces so they work together
# seamlessly, like having a master facility manager who coordinates
# all the different departments and services.
#
# EDUCATIONAL METAPHORS USED:
# ğŸ—ï¸ Urban Planning - Coordinating multiple buildings and services
# ğŸ­ Industrial Systems - Managing interconnected manufacturing processes
# ğŸ­ Theater Production - Coordinating different crews and technical systems
# ğŸ“¡ Communication Networks - Managing data flow between components
#

# ğŸ“‹ ORCHESTRATION VERSION - Which Docker Compose features to use
version: '3.8'

#
# ğŸ¢ SERVICE DIRECTORY - All the different components of our system
# ================================================================
#
# This section defines each "building" in our facility and how it should
# be constructed, configured, and maintained.
#
services:
  #
  # ğŸ¯ MAIN APPLICATION SERVICE - The core Debuggle error analysis system
  # ====================================================================
  #
  # This is like the main office building in our facility - it houses the
  # primary business logic and serves customers (handles error analysis requests).
  #
  debuggle-core:
    # ğŸ—ï¸ CONSTRUCTION INSTRUCTIONS - How to build this service
    build: 
      context: ..                    # ğŸ“ Build from parent directory (includes all source code)
      dockerfile: docker/Dockerfile  # ğŸ“‹ Use our custom construction instructions
    
    # ğŸšª ACCESS POINTS - How external systems can reach this service
    ports:
      - "8000:8000"                 # ğŸŒ Map external port 8000 to internal port 8000
    
    # âš™ï¸ OPERATIONAL SETTINGS - Configuration for how this service runs
    environment:
      - DEBUG=false                     # ğŸ­ Production mode (optimized, less verbose logging)
      - RATE_LIMIT_PER_MINUTE=100      # ğŸš¦ Traffic control (max 100 requests per minute)
    
    # ğŸ“ SHARED RESOURCES - External files this service needs access to
    volumes:
      - ../config/.env:/app/.env:ro    # ğŸ” Mount configuration file (read-only for security)
    
    # ğŸ”„ RESILIENCE POLICY - What to do if this service crashes
    restart: unless-stopped            # ğŸ›¡ï¸ Auto-restart if it crashes, but not if manually stopped
    
    # ğŸ¥ HEALTH MONITORING - How to check if this service is working properly
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]  # ğŸ©º Health check command
      interval: 30s                    # â° Check every 30 seconds
      timeout: 10s                     # â³ Wait up to 10 seconds for response
      retries: 3                       # ğŸ”„ Try 3 times before declaring unhealthy
      start_period: 40s                # ğŸš€ Wait 40 seconds after startup before first check

  # Optional: Add nginx proxy for production
  # nginx:
  #   image: nginx:alpine
  #   ports:
  #     - "80:80"
  #     - "443:443"
  #   volumes:
  #     - ./nginx.conf:/etc/nginx/nginx.conf:ro
  #   depends_on:
  #     - debuggle-trace
  #   restart: unless-stopped